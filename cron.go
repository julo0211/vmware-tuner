package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
)

// CronTuner handles scheduling
type CronTuner struct{}

// NewCronTuner creates a new cron tuner
func NewCronTuner() *CronTuner {
	return &CronTuner{}
}

// Run configures the schedule
func (ct *CronTuner) Run() error {
	PrintStep("Schedule Maintenance")

	cronFile := "/etc/cron.d/vmware-tuner"
	
	// Check if already scheduled
	if _, err := os.Stat(cronFile); err == nil {
		PrintInfo("Maintenance is currently SCHEDULED.")
		fmt.Print("Do you want to remove the schedule? (y/n): ")
		var resp string
		fmt.Scanln(&resp)
		if resp == "y" {
			os.Remove(cronFile)
			PrintSuccess("Schedule removed")
			return nil
		}
		return nil
	}

	PrintInfo("This will schedule:")
	PrintInfo("  - Daily Time Sync Check (04:00 AM)")
	PrintInfo("  - Weekly System Cleaning (Sunday 05:00 AM)")
	fmt.Println()
	fmt.Print("Enable this schedule? (y/n): ")
	
	var resp string
	fmt.Scanln(&resp)
	if resp != "y" {
		PrintInfo("Cancelled")
		return nil
	}

	// Get absolute path of current binary
	binPath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to get binary path: %w", err)
	}
	
	// Verify binary is in a good location
	if filepath.Dir(binPath) == "/tmp" || filepath.Dir(binPath) == "/var/tmp" {
		PrintWarning("Running from temporary directory!")
		PrintWarning("Please move 'vmware-tuner' to /usr/local/bin/ first.")
		return nil
	}

	// Create cron content
	// 0 4 * * * root /path/to/vmware-tuner --timesync-only (we need to implement silent flags later or just use shell commands)
	// Actually, since our tool is interactive, we should probably just schedule the raw commands for safety/simplicity
	// OR we assume the user will run the tool with flags.
	// Let's use raw commands for reliability, as the tool might move.
	
	content := `# VMware Tuner Maintenance
# Generated by vmware-tuner

# Daily Time Sync (Force sync if using chrony)
0 4 * * * root systemctl is-active chronyd >/dev/null && chronyc makestep >/dev/null 2>&1

# Weekly Cleaning (Safe vacuum)
0 5 * * 0 root journalctl --vacuum-time=3d >/dev/null 2>&1 && apt-get clean >/dev/null 2>&1 || yum clean all >/dev/null 2>&1
`

	if err := os.WriteFile(cronFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write cron file: %w", err)
	}

	PrintSuccess("Maintenance scheduled successfully!")
	PrintInfo("Created %s", cronFile)

	return nil
}
