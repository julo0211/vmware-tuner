package main

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// SchedulerTuner handles I/O scheduler optimization
type SchedulerTuner struct {
	UdevRulePath string
	DryRun       bool
}

// NewSchedulerTuner creates a new scheduler tuner
func NewSchedulerTuner(dryRun bool) *SchedulerTuner {
	return &SchedulerTuner{
		UdevRulePath: "/etc/udev/rules.d/60-scheduler.rules",
		DryRun:       dryRun,
	}
}

// GetUdevRules returns the udev rules for I/O scheduler
func (st *SchedulerTuner) GetUdevRules() string {
	return `# I/O Scheduler optimization for VMware VMs
# Generated by vmware-tuner

# Use 'none' (or 'noop' on older kernels) for all block devices
# This is optimal for VMs as the hypervisor handles I/O scheduling

# For SSDs and virtual disks (rotational=0)
ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/rotational}=="0", ATTR{queue/scheduler}="none"

# For HDDs (rotational=1) - still use none in VMs
ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/rotational}=="1", ATTR{queue/scheduler}="none"

# VMware PVSCSI devices
ACTION=="add|change", KERNEL=="sd[a-z]", DRIVERS=="vmw_pvscsi", ATTR{queue/scheduler}="none"

# Increase queue depth for better performance
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/nr_requests}="256"
ACTION=="add|change", KERNEL=="nvme[0-9]n[0-9]", ATTR{queue/nr_requests}="256"

# Read-ahead optimization (in KB)
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{bdi/read_ahead_kb}="256"
ACTION=="add|change", KERNEL=="nvme[0-9]n[0-9]", ATTR{bdi/read_ahead_kb}="256"
`
}

// Apply applies I/O scheduler optimizations
func (st *SchedulerTuner) Apply(backup *BackupManager) error {
	PrintStep("Configuring I/O scheduler")

	rules := st.GetUdevRules()

	if st.DryRun {
		PrintInfo("Would create: %s", st.UdevRulePath)
		PrintInfo("Udev rules preview:")
		fmt.Println(rules)
		return nil
	}

	// Backup existing rules if they exist
	if err := backup.BackupFile(st.UdevRulePath); err != nil {
		return fmt.Errorf("failed to backup udev rules: %w", err)
	}

	// Write udev rules
	if err := os.WriteFile(st.UdevRulePath, []byte(rules), 0644); err != nil {
		return fmt.Errorf("failed to write udev rules: %w", err)
	}

	PrintSuccess("Created %s", st.UdevRulePath)

	// Reload udev rules
	PrintInfo("Reloading udev rules...")
	cmd := exec.Command("udevadm", "control", "--reload-rules")
	if output, err := cmd.CombinedOutput(); err != nil {
		PrintWarning("Failed to reload udev rules: %v", err)
		fmt.Println(string(output))
	} else {
		PrintSuccess("Udev rules reloaded")
	}

	// Apply to current block devices immediately
	if err := st.ApplyToCurrentDevices(); err != nil {
		PrintWarning("Some devices may require a reboot for scheduler changes")
	}

	return nil
}

// ApplyToCurrentDevices applies scheduler changes to currently attached devices
func (st *SchedulerTuner) ApplyToCurrentDevices() error {
	PrintInfo("Applying I/O scheduler to current devices...")

	// Find all block devices
	devices, err := filepath.Glob("/sys/block/sd*")
	if err != nil {
		return err
	}

	nvmeDevices, _ := filepath.Glob("/sys/block/nvme*")
	devices = append(devices, nvmeDevices...)

	successCount := 0
	failCount := 0

	for _, device := range devices {
		deviceName := filepath.Base(device)
		schedulerPath := filepath.Join(device, "queue", "scheduler")

		// Set scheduler to 'none'
		if err := st.setScheduler(schedulerPath, "none"); err != nil {
			// Try 'noop' as fallback (older kernels)
			if err := st.setScheduler(schedulerPath, "noop"); err != nil {
				PrintWarning("Failed to set scheduler for %s: %v", deviceName, err)
				failCount++
				continue
			}
		}

		// Set nr_requests
		nrRequestsPath := filepath.Join(device, "queue", "nr_requests")
		if err := os.WriteFile(nrRequestsPath, []byte("256"), 0644); err != nil {
			// Not critical, just warn
			PrintWarning("Could not set nr_requests for %s", deviceName)
		}

		// Set read_ahead_kb
		readAheadPath := filepath.Join(device, "bdi", "read_ahead_kb")
		if err := os.WriteFile(readAheadPath, []byte("256"), 0644); err != nil {
			// Not critical, just warn
			PrintWarning("Could not set read_ahead_kb for %s", deviceName)
		}

		successCount++
		PrintSuccess("Configured %s", deviceName)
	}

	if successCount > 0 {
		PrintSuccess("Applied I/O scheduler to %d device(s)", successCount)
	}
	if failCount > 0 {
		return fmt.Errorf("failed to configure %d device(s)", failCount)
	}

	return nil
}

// setScheduler sets the I/O scheduler for a device
func (st *SchedulerTuner) setScheduler(schedulerPath, scheduler string) error {
	return os.WriteFile(schedulerPath, []byte(scheduler), 0644)
}

// ShowCurrent displays current I/O scheduler settings
func (st *SchedulerTuner) ShowCurrent() error {
	PrintStep("Current I/O scheduler settings")

	// Find all block devices
	devices, err := filepath.Glob("/sys/block/sd*")
	if err != nil {
		return err
	}

	nvmeDevices, _ := filepath.Glob("/sys/block/nvme*")
	devices = append(devices, nvmeDevices...)

	if len(devices) == 0 {
		PrintWarning("No block devices found")
		return nil
	}

	for _, device := range devices {
		deviceName := filepath.Base(device)
		schedulerPath := filepath.Join(device, "queue", "scheduler")

		data, err := os.ReadFile(schedulerPath)
		if err != nil {
			PrintWarning("Could not read scheduler for %s", deviceName)
			continue
		}

		// Extract current scheduler (marked with [brackets])
		schedulerLine := strings.TrimSpace(string(data))
		current := "unknown"

		// Find scheduler in brackets
		if start := strings.Index(schedulerLine, "["); start != -1 {
			if end := strings.Index(schedulerLine[start:], "]"); end != -1 {
				current = schedulerLine[start+1 : start+end]
			}
		}

		// Get read-ahead value
		readAheadPath := filepath.Join(device, "bdi", "read_ahead_kb")
		readAhead := "N/A"
		if data, err := os.ReadFile(readAheadPath); err == nil {
			readAhead = strings.TrimSpace(string(data)) + " KB"
		}

		// Get queue depth
		nrRequestsPath := filepath.Join(device, "queue", "nr_requests")
		nrRequests := "N/A"
		if data, err := os.ReadFile(nrRequestsPath); err == nil {
			nrRequests = strings.TrimSpace(string(data))
		}

		fmt.Printf("\n  Device: %s\n", deviceName)
		fmt.Printf("  Scheduler: %s\n", current)
		fmt.Printf("  Read-ahead: %s\n", readAhead)
		fmt.Printf("  Queue depth: %s\n", nrRequests)
	}

	return nil
}

// Verify checks if the udev rules have been applied
func (st *SchedulerTuner) Verify() error {
	if _, err := os.Stat(st.UdevRulePath); os.IsNotExist(err) {
		return fmt.Errorf("udev rules file not found: %s", st.UdevRulePath)
	}

	PrintSuccess("I/O scheduler udev rules exist")
	return nil
}
