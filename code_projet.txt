==========================================
FICHIER : cmd\vmware-tuner\main.go
==========================================
package main

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/fatih/color"
	"github.com/spf13/cobra"

	"vmware-tuner/internal/tuner"
)

var (
	version = "1.0.0"
	dryRun  bool
	noGrub  bool
	noSysctl bool
	noFstab bool
	noIO    bool
	noNet   bool
	installTools bool
	doDebloat    bool
)

func main() {
	var rootCmd = &cobra.Command{
		Use:   "vmware-tuner",
		Short: "VMware VM Performance Tuning Tool",
		Long: `VMware VM Performance Tuner

A comprehensive tool to optimize VMware virtual machines for maximum performance.
This tool applies industry-standard best practices including:
  - Kernel boot parameter optimization
  - Sysctl tuning for memory and network
  - Filesystem mount options optimization
  - I/O scheduler configuration
  - Network interface optimization

All changes are backed up and can be rolled back.`,
		Version: version,
		RunE:    runTuner,
	}

	var showCmd = &cobra.Command{
		Use:   "show",
		Short: "Show current system configuration",
		Long:  "Display current system settings for all tuning categories",
		RunE:  showConfig,
	}

	var verifyCmd = &cobra.Command{
		Use:   "verify",
		Short: "Verify tuning has been applied",
		Long:  "Check if tuning configurations are present on the system",
		RunE:  verifyConfig,
	}

	// Root command flags
	rootCmd.Flags().BoolVar(&dryRun, "dry-run", false, "Show what would be done without making changes")
	rootCmd.Flags().BoolVar(&noGrub, "no-grub", false, "Skip GRUB boot parameter tuning")
	rootCmd.Flags().BoolVar(&noSysctl, "no-sysctl", false, "Skip sysctl parameter tuning")
	rootCmd.Flags().BoolVar(&noFstab, "no-fstab", false, "Skip fstab optimization")
	rootCmd.Flags().BoolVar(&noIO, "no-io", false, "Skip I/O scheduler tuning")
	rootCmd.Flags().BoolVar(&noNet, "no-network", false, "Skip network tuning")
	rootCmd.Flags().BoolVar(&installTools, "install-tools", true, "Install open-vm-tools if missing")
	rootCmd.Flags().BoolVar(&doDebloat, "debloat", false, "Disable unnecessary services (Server Slim)")

	rootCmd.AddCommand(showCmd)
	rootCmd.AddCommand(verifyCmd)

	if err := rootCmd.Execute(); err != nil {
		os.Exit(1)
	}
}

func runTuner(cmd *cobra.Command, args []string) error {
	tuner.Banner()

	// Check if running interactively (no flags)
	if !cmd.Flags().Changed("dry-run") &&
		!cmd.Flags().Changed("no-grub") &&
		!cmd.Flags().Changed("no-sysctl") &&
		!cmd.Flags().Changed("no-fstab") &&
		!cmd.Flags().Changed("no-io") &&
		!cmd.Flags().Changed("no-network") &&
		!cmd.Flags().Changed("install-tools") &&
		!cmd.Flags().Changed("debloat") {

		// Initialize distro manager for all interactive commands
		distro, err := tuner.NewDistroManager()
		if err != nil {
			// Fallback if detection fails
			distro = &tuner.DistroManager{Type: tuner.DistroUnknown}
		}

		for {
			choice := showMainMenu()

			if choice == 0 {
				tuner.PrintInfo("Exiting...")
				return nil
			}

			var err error

			if choice == 2 {
				if err = tuner.CheckRoot(); err == nil {
					err = runRollbackInteractive()
				}
			} else if choice == 3 {
				if err = tuner.CheckRoot(); err == nil {
					audit := tuner.NewAuditTuner(distro)
					err = audit.RunAudit()
				}
			} else if choice == 4 {
				if err = tuner.CheckRoot(); err == nil {
					disk := tuner.NewDiskTuner(distro)
					err = disk.ExpandRoot()
				}
			} else if choice == 5 {
				if err = tuner.CheckRoot(); err == nil {
					timeSync := tuner.NewTimeSyncTuner(distro)
					err = timeSync.Run()
				}
			} else if choice == 6 {
				if err = tuner.CheckRoot(); err == nil {
					cleaner := tuner.NewCleanerTuner(distro)
					err = cleaner.Run()
				}
			} else if choice == 7 {
				if err = tuner.CheckRoot(); err == nil {
					backup := tuner.NewBackupManager()
					if err = backup.Initialize(); err == nil {
						ssh := tuner.NewSSHTuner(backup)
						err = ssh.Run()
					}
				}
			} else if choice == 8 {
				if err = tuner.CheckRoot(); err == nil {
					cron := tuner.NewCronTuner()
					err = cron.Run()
				}
			} else if choice == 9 {
				info := tuner.NewInfoTuner()
				err = info.Run()
			} else if choice == 10 {
				bench := tuner.NewBenchmarkTuner()
				err = bench.Run()
			} else if choice == 11 {
				if err = tuner.CheckRoot(); err == nil {
					template := tuner.NewTemplateTuner()
					err = template.Run()
				}
			} else if choice == 12 {
				hardware := tuner.NewHardwareTuner(distro)
				err = hardware.Run()
			} else if choice == 13 {
				if err = tuner.CheckRoot(); err == nil {
					swap := tuner.NewSwapTuner()
					err = swap.Run()
				}
			} else if choice == 14 {
				if err = tuner.CheckRoot(); err == nil {
					logDoctor := tuner.NewLogDoctorTuner(distro)
					err = logDoctor.Run()
				}
			} else if choice == 15 {
				if err = tuner.CheckRoot(); err == nil {
					docker := tuner.NewDockerTuner()
					err = docker.Run()
				}
			} else if choice == 16 {
				if err = tuner.CheckRoot(); err == nil {
					update := tuner.NewUpdateTuner(distro)
					err = update.Run()
				}
			}

			if err != nil {
				tuner.PrintError("%v", err)
			}

			fmt.Println()
			fmt.Println("Press Enter to return to menu...")
			bufio.NewReader(os.Stdin).ReadBytes('\n')
		}
	}

	// Check if running as root
	if !dryRun {
		if err := tuner.CheckRoot(); err != nil {
			tuner.PrintError("%v", err)
			return err
		}
	}

	// Check if running on VMware
	isVMware, err := tuner.IsVMware()
	if err != nil {
		tuner.PrintWarning("Could not determine if running on VMware: %v", err)
	} else if !isVMware {
		tuner.PrintWarning("This system does not appear to be a VMware VM")
		tuner.PrintWarning("Tuning parameters are optimized for VMware environments")
		fmt.Print("\nContinue anyway? (yes/no): ")
		var response string
		fmt.Scanln(&response)
		if response != "yes" {
			tuner.PrintInfo("Tuning cancelled")
			return nil
		}
	} else {
		tuner.PrintSuccess("Detected VMware virtual machine")
	}

	// Initialize distro manager
	distro, err := tuner.NewDistroManager()
	if err != nil {
		tuner.PrintWarning("Could not detect distribution: %v", err)
		// Continue with default/unknown
		distro = &tuner.DistroManager{Type: tuner.DistroUnknown}
	} else {
		tuner.PrintSuccess("Detected distribution: %s", distro.Name)
	}

	// Check and install dependencies
	if !dryRun && !noNet {
		if err := distro.InstallPackage("ethtool"); err != nil {
			tuner.PrintWarning("Failed to install ethtool: %v", err)
			tuner.PrintWarning("Network tuning might fail")
		}
	}

	// Determine what will be tuned
	var modules []string
	if !noGrub {
		modules = append(modules, "GRUB boot parameters")
	}
	if !noSysctl {
		modules = append(modules, "Sysctl kernel parameters")
	}
	if !noFstab {
		modules = append(modules, "Filesystem mount options")
	}
	if !noIO {
		modules = append(modules, "I/O scheduler configuration")
	}
	if !noNet {
		modules = append(modules, "Network interface optimization")
	}
	if installTools {
		modules = append(modules, "VMware Tools verification/installation")
	}
	if doDebloat {
		modules = append(modules, "Server Slim (disable unused services)")
	}

	if len(modules) == 0 {
		tuner.PrintError("No tuning modules selected")
		return fmt.Errorf("nothing to do")
	}

	tuner.Summary(modules)

	if dryRun {
		tuner.PrintInfo("DRY RUN MODE - No changes will be made")
		fmt.Println()
	} else {
		fmt.Print("Continue with tuning? (yes/no): ")
		var response string
		fmt.Scanln(&response)
		if response != "yes" {
			tuner.PrintInfo("Tuning cancelled")
			return nil
		}
	}

	// Initialize backup manager
	backup := tuner.NewBackupManager()
	if !dryRun {
		if err := backup.Initialize(); err != nil {
			tuner.PrintError("Failed to initialize backup: %v", err)
			return err
		}
		tuner.PrintSuccess("Backup directory created: %s", backup.BackupDir)
	}

	rebootRequired := false

	// Apply GRUB tuning
	if !noGrub {
		grub := tuner.NewGrubTuner(dryRun, distro)
		if err := grub.Apply(backup); err != nil {
			tuner.PrintError("GRUB tuning failed: %v", err)
		} else {
			rebootRequired = true
		}
	}

	// Apply sysctl tuning
	if !noSysctl {
		sysctl := tuner.NewSysctlTuner(dryRun)
		if err := sysctl.Apply(backup); err != nil {
			tuner.PrintError("Sysctl tuning failed: %v", err)
		}
	}

	// Apply fstab tuning
	if !noFstab {
		fstab := tuner.NewFstabTuner(dryRun)
		if err := fstab.Apply(backup); err != nil {
			tuner.PrintError("Fstab tuning failed: %v", err)
		}
	}

	// Apply I/O scheduler tuning
	if !noIO {
		scheduler := tuner.NewSchedulerTuner(dryRun)
		if err := scheduler.Apply(backup); err != nil {
			tuner.PrintError("I/O scheduler tuning failed: %v", err)
		}
	}

	// Apply network tuning
	if !noNet {
		network := tuner.NewNetworkTuner(dryRun)
		if err := network.Apply(backup); err != nil {
			tuner.PrintError("Network tuning failed: %v", err)
		}
	}

	// Apply VM Tools
	if installTools {
		tools := tuner.NewVMToolsTuner(dryRun, distro)
		if err := tools.Apply(); err != nil {
			tuner.PrintError("VM Tools tuning failed: %v", err)
		}
	}

	// Apply Debloat (Interactive or Flag)
	debloat := tuner.NewDebloatTuner(dryRun)
	if doDebloat {
		// Flag provided: do it automatically
		if err := debloat.Apply(backup); err != nil {
			tuner.PrintError("Debloat failed: %v", err)
		}
	} else if !dryRun {
		// No flag: ask interactively
		services := debloat.GetBloatServices()
		if len(services) > 0 {
			tuner.PrintStep("Server Slim Mode (Optional)")
			tuner.PrintInfo("Found %d services that are usually unnecessary on servers:", len(services))
			for _, svc := range services {
				fmt.Printf("  - %s: %s\n", svc.Name, svc.Description)
			}
			fmt.Println()
			fmt.Print("Do you want to disable these services? (y/n): ")
			var response string
			fmt.Scanln(&response)
			if response == "y" || response == "yes" {
				if err := debloat.DisableServices(services, backup); err != nil {
					tuner.PrintError("Debloat failed: %v", err)
				}
			} else {
				tuner.PrintInfo("Skipping Server Slim optimization")
			}
		}
	}

	// Create rollback script
	if !dryRun {
		if err := backup.CreateRollbackScript(); err != nil {
			tuner.PrintWarning("Failed to create rollback script: %v", err)
		}
	}

	if !dryRun {
		tuner.CompletionMessage(rebootRequired)
		
		if rebootRequired {
			fmt.Print("Do you want to reboot now? (y/n): ")
			var response string
			fmt.Scanln(&response)
			if response == "y" || response == "yes" {
				tuner.PrintInfo("Rebooting system...")
				exec.Command("reboot").Run()
			} else {
				tuner.PrintInfo("Please remember to reboot later")
			}
		}
	} else {
		fmt.Println()
		tuner.PrintInfo("DRY RUN completed - no changes were made")
		tuner.PrintInfo("Run without --dry-run to apply changes")
	}

	return nil
}

func showConfig(cmd *cobra.Command, args []string) error {
	tuner.Banner()
	tuner.PrintInfo("Current System Configuration")
	fmt.Println()

	// Initialize distro manager for config paths
	distro, _ := tuner.NewDistroManager()

	// Show GRUB config
	grub := tuner.NewGrubTuner(false, distro)
	if err := grub.ShowCurrent(); err != nil {
		tuner.PrintWarning("Could not show GRUB config: %v", err)
	}

	// Show sysctl config
	sysctl := tuner.NewSysctlTuner(false)
	if err := sysctl.ShowCurrent(); err != nil {
		tuner.PrintWarning("Could not show sysctl config: %v", err)
	}

	// Show fstab config
	fstab := tuner.NewFstabTuner(false)
	if err := fstab.ShowCurrent(); err != nil {
		tuner.PrintWarning("Could not show fstab config: %v", err)
	}

	// Show I/O scheduler config
	scheduler := tuner.NewSchedulerTuner(false)
	if err := scheduler.ShowCurrent(); err != nil {
		tuner.PrintWarning("Could not show I/O scheduler config: %v", err)
	}

	// Show network config
	network := tuner.NewNetworkTuner(false)
	if err := network.ShowCurrent(); err != nil {
		tuner.PrintWarning("Could not show network config: %v", err)
	}

	return nil
}

func verifyConfig(cmd *cobra.Command, args []string) error {
	tuner.Banner()
	tuner.PrintStep("Verifying tuning configuration")

	allGood := true

	// Verify sysctl
	sysctl := tuner.NewSysctlTuner(false)
	if err := sysctl.Verify(); err != nil {
		tuner.PrintWarning("Sysctl: %v", err)
		allGood = false
	}

	// Verify I/O scheduler
	scheduler := tuner.NewSchedulerTuner(false)
	if err := scheduler.Verify(); err != nil {
		tuner.PrintWarning("I/O Scheduler: %v", err)
		allGood = false
	}

	// Verify network
	network := tuner.NewNetworkTuner(false)
	if err := network.Verify(); err != nil {
		tuner.PrintWarning("Network: %v", err)
		allGood = false
	}

	fmt.Println()
	if allGood {
		tuner.PrintSuccess("All tuning configurations are present")
	} else {
		tuner.PrintWarning("Some tuning configurations are missing")
		tuner.PrintInfo("Run 'vmware-tuner' to apply tuning")
	}

	return nil
}

func showMainMenu() int {
	// Clear screen (optional, but nice for looping)
	fmt.Print("\033[H\033[2J")
	
	tuner.Banner()
	fmt.Println("What do you want to do?")
	fmt.Println("  [1] Optimize this VM (Tuning)")
	fmt.Println("  [2] Restore a backup (Rollback)")
	fmt.Println("  [3] Audit System (Score)")
	fmt.Println("  [4] Expand Disk")
	fmt.Println("  [5] Fix Time Sync")
	fmt.Println("  [6] Clean System")
	fmt.Println("  [7] Secure SSH")
	fmt.Println("  [8] Schedule Maintenance")
	fmt.Println("  [9] System Info")
	fmt.Println("  [10] Network Benchmark")
	fmt.Println("  [11] Seal VM for Template (Expert)")
	fmt.Println("  [12] Check Virtual Hardware")
	fmt.Println("  [13] Manage Swap")
	fmt.Println("  [14] Scan Logs for Errors")

	// Check Docker
	if _, err := exec.LookPath("docker"); err == nil {
		fmt.Println("  [15] Optimize Docker")
	} else {
		color.Red("  [15] Optimize Docker (Not Installed)")
	}

	fmt.Println("  [16] Safe System Update")
	fmt.Println("  [0]  Exit")
	fmt.Println()
	fmt.Print("Choice (0-16): ")

	reader := bufio.NewReader(os.Stdin)
	input, _ := reader.ReadString('\n')
	choice := strings.TrimSpace(input)

	if choice == "0" { return 0 }
	if choice == "2" { return 2 }
	if choice == "3" { return 3 }
	if choice == "4" { return 4 }
	if choice == "5" { return 5 }
	if choice == "6" { return 6 }
	if choice == "7" { return 7 }
	if choice == "8" { return 8 }
	if choice == "9" { return 9 }
	if choice == "10" { return 10 }
	if choice == "11" { return 11 }
	if choice == "12" { return 12 }
	if choice == "13" { return 13 }
	if choice == "14" { return 14 }
	if choice == "15" { return 15 }
	if choice == "16" { return 16 }
	return 1
}

func runRollbackInteractive() error {
	tuner.PrintStep("Restore Backup")

	backups, err := tuner.ListBackups()
	if err != nil {
		return fmt.Errorf("failed to list backups: %w", err)
	}

	if len(backups) == 0 {
		tuner.PrintWarning("No backups found.")
		return nil
	}

	fmt.Println("Available backups:")
	for i, backup := range backups {
		fmt.Printf("  [%d] %s\n", i+1, backup)
	}
	fmt.Println("  [c] Cancel")
	fmt.Println()

	fmt.Print("Select backup to restore: ")
	var selection string
	fmt.Scanln(&selection)

	if selection == "c" || selection == "C" {
		tuner.PrintInfo("Rollback cancelled")
		return nil
	}

	var index int
	_, err = fmt.Sscanf(selection, "%d", &index)
	if err != nil || index < 1 || index > len(backups) {
		tuner.PrintError("Invalid selection")
		return nil
	}

	targetBackup := backups[index-1]
	backupDir := filepath.Join("/root", ".vmware-tuner-backups", targetBackup)
	rollbackScript := filepath.Join(backupDir, "rollback.sh")

	if _, err := os.Stat(rollbackScript); os.IsNotExist(err) {
		return fmt.Errorf("rollback script not found in %s", backupDir)
	}

	tuner.PrintInfo("Executing rollback script from %s...", targetBackup)
	
	cmd := exec.Command("/bin/bash", rollbackScript)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Stdin = os.Stdin 

	if err := cmd.Run(); err != nil {
		return fmt.Errorf("rollback failed: %w", err)
	}

	return nil
}


==========================================
FICHIER : internal\tuner\audit.go
==========================================
package tuner

import (
	"fmt"
	"strings"
)

// AuditTuner handles system auditing
type AuditTuner struct {
	Distro *DistroManager
}

// NewAuditTuner creates a new audit tuner
func NewAuditTuner(distro *DistroManager) *AuditTuner {
	return &AuditTuner{
		Distro: distro,
	}
}

// RunAudit performs the audit and prints the report
func (at *AuditTuner) RunAudit() error {
	PrintStep("System Optimization Audit")

	score := 0
	maxScore := 100

	// 1. Check VM Tools (30 points)
	tools := NewVMToolsTuner(true, at.Distro)
	installed, updateAvailable, days, _ := tools.CheckUpdateStatus()
	
	if installed {
		if !updateAvailable {
			PrintSuccess("VMware Tools installed and up-to-date (+30)")
			score += 30
		} else {
			// Update available, deduct points based on age
			points := 25
			if days > 180 {
				points = 10
			} else if days > 90 {
				points = 15
			} else if days > 30 {
				points = 20
			}
			PrintWarning("VMware Tools update available (installed %d days ago) (+%d/30)", days, points)
			PrintInfo("Recommendation: Run 'Safe System Update' or update open-vm-tools")
			score += points
		}
	} else {
		PrintError("VMware Tools missing (0/30)")
	}

	// 2. Check GRUB (30 points)
	grub := NewGrubTuner(true, at.Distro)
	config, _, err := grub.ParseGrubConfig()
	if err == nil {
		cmdline := config["GRUB_CMDLINE_LINUX_DEFAULT"]
		if strings.Contains(cmdline, "elevator=noop") || strings.Contains(cmdline, "elevator=none") {
			PrintSuccess("I/O Scheduler optimized (+15)")
			score += 15
		} else {
			PrintWarning("I/O Scheduler not optimized (0/15)")
		}
		
		if strings.Contains(cmdline, "transparent_hugepage=madvise") {
			PrintSuccess("Memory pages optimized (+15)")
			score += 15
		} else {
			PrintWarning("Memory pages not optimized (0/15)")
		}
	} else {
		PrintWarning("Could not read GRUB config")
	}

	// 3. Check Bloatware (20 points)
	debloat := NewDebloatTuner(true)
	bloat := debloat.GetBloatServices()
	if len(bloat) == 0 {
		PrintSuccess("No unnecessary services found (+20)")
		score += 20
	} else {
		PrintWarning("Found %d unnecessary services (0/20)", len(bloat))
		for _, svc := range bloat {
			fmt.Printf("    - %s\n", svc.Name)
		}
	}

	// 4. Check Sysctl (20 points)
	// Simple check for swappiness
	// In a real implementation we would check actual values
	// For now, let's assume if the config file exists, it's good
	if FileExists("/etc/sysctl.d/99-vmware-performance.conf") {
		PrintSuccess("Sysctl optimizations present (+20)")
		score += 20
	} else {
		PrintWarning("Sysctl optimizations missing (0/20)")
	}

	fmt.Println()
	PrintStep("Audit Result")
	
	fmt.Printf("Final Score: %d/%d\n", score, maxScore)
	
	if score == 100 {
		PrintSuccess("System is fully optimized! ðŸš€")
	} else if score >= 70 {
		PrintInfo("System is well optimized, but could be better.")
	} else {
		PrintWarning("System requires optimization.")
		PrintInfo("Run 'Optimize this VM' from the main menu.")
	}

	return nil
}


==========================================
FICHIER : internal\tuner\backup.go
==========================================
package tuner

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"time"
)

// BackupManager handles configuration file backups
type BackupManager struct {
	BackupDir string
	Timestamp string
}

// NewBackupManager creates a new backup manager
func NewBackupManager() *BackupManager {
	timestamp := time.Now().Format("20060102-150405")
	backupDir := filepath.Join("/root", ".vmware-tuner-backups", timestamp)

	return &BackupManager{
		BackupDir: backupDir,
		Timestamp: timestamp,
	}
}

// Initialize creates the backup directory
func (bm *BackupManager) Initialize() error {
	if err := os.MkdirAll(bm.BackupDir, 0700); err != nil {
		return fmt.Errorf("failed to create backup directory: %w", err)
	}

	// Create a README in the backup directory
	readme := filepath.Join(bm.BackupDir, "README.txt")
	content := fmt.Sprintf(`VMware Tuner Backup
Created: %s

This directory contains backups of system configuration files
before they were modified by vmware-tuner.

To restore a file:
  sudo cp <filename> /path/to/original/location

To restore all files, run:
  sudo vmware-tuner --rollback %s
`, time.Now().Format(time.RFC3339), bm.Timestamp)

	if err := os.WriteFile(readme, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to create README: %w", err)
	}

	return nil
}

// BackupFile creates a backup of the specified file
func (bm *BackupManager) BackupFile(filePath string) error {
	// Check if source file exists
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		// File doesn't exist, nothing to backup
		return nil
	}

	// Open source file
	source, err := os.Open(filePath)
	if err != nil {
		return fmt.Errorf("failed to open source file %s: %w", filePath, err)
	}
	defer source.Close()

	// Create backup filename (preserve directory structure)
	backupPath := filepath.Join(bm.BackupDir, filepath.Base(filePath))

	// Create backup file
	backup, err := os.Create(backupPath)
	if err != nil {
		return fmt.Errorf("failed to create backup file %s: %w", backupPath, err)
	}
	defer backup.Close()

	// Copy contents
	if _, err := io.Copy(backup, source); err != nil {
		return fmt.Errorf("failed to copy file contents: %w", err)
	}

	// Preserve permissions
	sourceInfo, err := os.Stat(filePath)
	if err == nil {
		if err := os.Chmod(backupPath, sourceInfo.Mode()); err != nil {
			return fmt.Errorf("failed to preserve permissions: %w", err)
		}
	}

	return nil
}

// CreateRollbackScript creates a script to restore all backed up files
func (bm *BackupManager) CreateRollbackScript() error {
	scriptPath := filepath.Join(bm.BackupDir, "rollback.sh")

	script := `#!/bin/bash
# VMware Tuner Rollback Script
# This script restores all configuration files to their pre-tuning state

set -e

echo "VMware Tuner - Rollback Script"
echo "==============================="
echo ""
echo "This will restore the following files:"
echo ""

# Show what will be restored
if [ -f "fstab" ]; then
    echo "  - /etc/fstab"
fi
if [ -f "grub" ]; then
    echo "  - /etc/default/grub"
fi
if [ -f "99-vmware-performance.conf" ]; then
    echo "  - /etc/sysctl.d/99-vmware-performance.conf"
fi
if [ -f "60-scheduler.rules" ]; then
    echo "  - /etc/udev/rules.d/60-scheduler.rules"
fi

echo ""
read -p "Continue with rollback? (yes/no): " confirm

if [ "$confirm" != "yes" ]; then
    echo "Rollback cancelled."
    exit 0
fi

echo ""
echo "Restoring files..."

if [ -f "fstab" ]; then
    cp -v fstab /etc/fstab
    echo "âœ“ Restored /etc/fstab"
fi

if [ -f "grub" ]; then
    cp -v grub /etc/default/grub
    update-grub
    echo "âœ“ Restored /etc/default/grub (grub updated)"
fi

if [ -f "99-vmware-performance.conf" ]; then
    rm -f /etc/sysctl.d/99-vmware-performance.conf
    echo "âœ“ Removed /etc/sysctl.d/99-vmware-performance.conf"
    sysctl --system
    echo "âœ“ Reloaded sysctl configuration"
fi

if [ -f "60-scheduler.rules" ]; then
    rm -f /etc/udev/rules.d/60-scheduler.rules
    udevadm control --reload-rules
    echo "âœ“ Removed /etc/udev/rules.d/60-scheduler.rules"
    echo "âœ“ Removed /etc/udev/rules.d/60-scheduler.rules"
fi

if [ -f "services.txt" ]; then
    echo ""
    echo "Re-enabling disabled services..."
    while IFS= read -r service; do
        if [ ! -z "$service" ]; then
            systemctl enable --now "$service"
            echo "âœ“ Re-enabled $service"
        fi
    done < "services.txt"
fi

echo ""
echo "==============================="
echo "Rollback completed successfully!"
echo ""
echo "Note: Some changes require a reboot to take full effect."
echo "Run 'sudo reboot' when ready."
`

	if err := os.WriteFile(scriptPath, []byte(script), 0755); err != nil {
		return fmt.Errorf("failed to create rollback script: %w", err)
	}

	return nil
}

// GetBackupPath returns the full path to a backed up file
func (bm *BackupManager) GetBackupPath(filename string) string {
	return filepath.Join(bm.BackupDir, filename)
}

// ListBackups lists all available backup timestamps
func ListBackups() ([]string, error) {
	backupRoot := "/root/.vmware-tuner-backups"

	if _, err := os.Stat(backupRoot); os.IsNotExist(err) {
		return []string{}, nil
	}

	entries, err := os.ReadDir(backupRoot)
	if err != nil {
		return nil, fmt.Errorf("failed to read backup directory: %w", err)
	}

	var backups []string
	for _, entry := range entries {
		if entry.IsDir() {
			backups = append(backups, entry.Name())
		}
	}

	return backups, nil
}

// BackupServices saves a list of disabled services
func (bm *BackupManager) BackupServices(services []string) error {
	if len(services) == 0 {
		return nil
	}

	filePath := filepath.Join(bm.BackupDir, "services.txt")
	file, err := os.Create(filePath)
	if err != nil {
		return fmt.Errorf("failed to create services backup: %w", err)
	}
	defer file.Close()

	for _, svc := range services {
		if _, err := file.WriteString(svc + "\n"); err != nil {
			return fmt.Errorf("failed to write service to backup: %w", err)
		}
	}

	return nil
}


==========================================
FICHIER : internal\tuner\benchmark.go
==========================================
package tuner

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"os/exec"
	"strings"
	"time"
)

// BenchmarkTuner handles network benchmarking
type BenchmarkTuner struct{}

// NewBenchmarkTuner creates a new benchmark tuner
func NewBenchmarkTuner() *BenchmarkTuner {
	return &BenchmarkTuner{}
}

// Run performs the benchmark
func (bt *BenchmarkTuner) Run() error {
	PrintStep("Network Benchmark")

	// 1. Latency Test (Ping Gateway)
	PrintInfo("Testing latency...")
	gateway, err := getGateway()
	if err != nil {
		PrintWarning("Could not detect gateway: %v", err)
	} else {
		PrintInfo("Pinging gateway (%s)...", gateway)
		// ping -c 4 -i 0.2 <gateway>
		cmd := exec.Command("ping", "-c", "4", "-i", "0.2", gateway)
		output, err := cmd.CombinedOutput()
		if err != nil {
			PrintWarning("Ping failed: %v", err)
		} else {
			// Extract avg
			lines := strings.Split(string(output), "\n")
			for _, line := range lines {
				if strings.Contains(line, "rtt") || strings.Contains(line, "avg") {
					fmt.Printf("  -> %s\n", strings.TrimSpace(line))
				}
			}
		}
	}

	// 2. Download Speed Test
	fmt.Println()
	PrintInfo("Testing download speed...")
	PrintInfo("Downloading 100MB test file (will be deleted immediately)...")

	url := "http://speedtest.tele2.net/100MB.zip" // Reliable public speedtest file
	tmpFile := "/tmp/vmware-tuner-speedtest.tmp"

	// START TIMER
	start := time.Now()

	resp, err := http.Get(url)
	if err != nil {
		return fmt.Errorf("download failed: %v", err)
	}
	defer resp.Body.Close()

	out, err := os.Create(tmpFile)
	if err != nil {
		return fmt.Errorf("failed to create temp file: %v", err)
	}
	
	// CRITICAL: Ensure file is deleted
	defer func() {
		out.Close()
		os.Remove(tmpFile)
		PrintSuccess("Temporary file deleted")
	}()

	// Copy content
	written, err := io.Copy(out, resp.Body)
	if err != nil {
		return fmt.Errorf("download interrupted: %v", err)
	}

	// STOP TIMER
	elapsed := time.Since(start)

	// Calculate speed
	// written is bytes
	// elapsed is duration
	mb := float64(written) / 1024 / 1024
	seconds := elapsed.Seconds()
	speed := mb / seconds // MB/s

	fmt.Printf("  -> Downloaded %.2f MB in %.2f seconds\n", mb, seconds)
	PrintSuccess("Speed: %.2f MB/s (%.2f Mbps)", speed, speed*8)

	return nil
}

func getGateway() (string, error) {
	// ip route | grep default
	cmd := exec.Command("ip", "route")
	output, err := cmd.Output()
	if err != nil {
		return "", err
	}
	
	lines := strings.Split(string(output), "\n")
	for _, line := range lines {
		if strings.HasPrefix(line, "default") {
			parts := strings.Fields(line)
			if len(parts) >= 3 {
				return parts[2], nil
			}
		}
	}
	return "", fmt.Errorf("no default route found")
}


==========================================
FICHIER : internal\tuner\cleaner.go
==========================================
package tuner

import (
	"fmt"
	"os/exec"
)

// CleanerTuner handles system cleaning
type CleanerTuner struct {
	Distro *DistroManager
}

// NewCleanerTuner creates a new cleaner
func NewCleanerTuner(distro *DistroManager) *CleanerTuner {
	return &CleanerTuner{
		Distro: distro,
	}
}

// Run performs the cleaning
func (ct *CleanerTuner) Run() error {
	PrintStep("System Cleaner")

	PrintInfo("This will:")
	PrintInfo("  - Clean package manager cache")
	PrintInfo("  - Vacuum system logs (keep last 3 days)")
	PrintInfo("  - Remove old crash dumps")
	fmt.Println()
	fmt.Print("Continue? (y/n): ")
	
	var response string
	fmt.Scanln(&response)
	if response != "y" && response != "yes" {
		PrintInfo("Cancelled")
		return nil
	}

	// 1. Clean Package Cache
	PrintInfo("Cleaning package cache...")
	if ct.Distro.Type == DistroDebian {
		exec.Command("apt-get", "clean").Run()
		exec.Command("apt-get", "autoremove", "-y").Run()
	} else if ct.Distro.Type == DistroRHEL {
		if _, err := exec.LookPath("dnf"); err == nil {
			exec.Command("dnf", "clean", "all").Run()
			exec.Command("dnf", "autoremove", "-y").Run()
		} else {
			exec.Command("yum", "clean", "all").Run()
			exec.Command("yum", "autoremove", "-y").Run()
		}
	}
	PrintSuccess("Package cache cleaned")

	// 2. Vacuum Journal
	PrintInfo("Vacuuming system logs...")
	if err := exec.Command("journalctl", "--vacuum-time=3d").Run(); err != nil {
		PrintWarning("Failed to vacuum journal: %v", err)
	} else {
		PrintSuccess("Logs vacuumed (kept 3 days)")
	}

	// 3. Show Free Space
	PrintInfo("Current Disk Usage:")
	exec.Command("df", "-h", "/").Run()

	return nil
}


==========================================
FICHIER : internal\tuner\cron.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"path/filepath"
)

// CronTuner handles scheduling
type CronTuner struct{}

// NewCronTuner creates a new cron tuner
func NewCronTuner() *CronTuner {
	return &CronTuner{}
}

// Run configures the schedule
func (ct *CronTuner) Run() error {
	PrintStep("Schedule Maintenance")

	cronFile := "/etc/cron.d/vmware-tuner"
	
	// Check if already scheduled
	if _, err := os.Stat(cronFile); err == nil {
		PrintInfo("Maintenance is currently SCHEDULED.")
		fmt.Print("Do you want to remove the schedule? (y/n): ")
		var resp string
		fmt.Scanln(&resp)
		if resp == "y" {
			os.Remove(cronFile)
			PrintSuccess("Schedule removed")
			return nil
		}
		return nil
	}

	PrintInfo("This will schedule:")
	PrintInfo("  - Daily Time Sync Check (04:00 AM)")
	PrintInfo("  - Weekly System Cleaning (Sunday 05:00 AM)")
	fmt.Println()
	fmt.Print("Enable this schedule? (y/n): ")
	
	var resp string
	fmt.Scanln(&resp)
	if resp != "y" {
		PrintInfo("Cancelled")
		return nil
	}

	// Get absolute path of current binary
	binPath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to get binary path: %w", err)
	}
	
	// Verify binary is in a good location
	if filepath.Dir(binPath) == "/tmp" || filepath.Dir(binPath) == "/var/tmp" {
		PrintWarning("Running from temporary directory!")
		PrintWarning("Please move 'vmware-tuner' to /usr/local/bin/ first.")
		return nil
	}

	// Create cron content
	// 0 4 * * * root /path/to/vmware-tuner --timesync-only (we need to implement silent flags later or just use shell commands)
	// Actually, since our tool is interactive, we should probably just schedule the raw commands for safety/simplicity
	// OR we assume the user will run the tool with flags.
	// Let's use raw commands for reliability, as the tool might move.
	
	content := `# VMware Tuner Maintenance
# Generated by vmware-tuner

# Daily Time Sync (Force sync if using chrony)
0 4 * * * root systemctl is-active chronyd >/dev/null && chronyc makestep >/dev/null 2>&1

# Weekly Cleaning (Safe vacuum)
0 5 * * 0 root journalctl --vacuum-time=3d >/dev/null 2>&1 && apt-get clean >/dev/null 2>&1 || yum clean all >/dev/null 2>&1
`

	if err := os.WriteFile(cronFile, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write cron file: %w", err)
	}

	PrintSuccess("Maintenance scheduled successfully!")
	PrintInfo("Created %s", cronFile)

	return nil
}


==========================================
FICHIER : internal\tuner\debloat.go
==========================================
package tuner

import (
	"fmt"
	"os/exec"
)

// DebloatTuner handles disabling unnecessary services
type DebloatTuner struct {
	DryRun bool
}

// NewDebloatTuner creates a new debloat tuner
func NewDebloatTuner(dryRun bool) *DebloatTuner {
	return &DebloatTuner{
		DryRun: dryRun,
	}
}

// Service represents a system service
type Service struct {
	Name        string
	Description string
	Active      bool
}

// GetBloatServices returns a list of potentially unnecessary services
func (dt *DebloatTuner) GetBloatServices() []Service {
	// List of services to check
	targets := []Service{
		{Name: "cups", Description: "Printing service (CUPS)"},
		{Name: "cups-browsed", Description: "Printer discovery"},
		{Name: "avahi-daemon", Description: "mDNS/DNS-SD (Avahi)"},
		{Name: "bluetooth", Description: "Bluetooth service"},
		{Name: "wpa_supplicant", Description: "Wi-Fi security (WPA)"},
		{Name: "modemmanager", Description: "Modem Manager"},
		{Name: "snapd", Description: "Snap Package Manager (consumes loop devices)"},
		{Name: "lxcfs", Description: "LXC File System (if not using containers)"},
		{Name: "multipathd", Description: "Multipath Device Daemon (unless using SAN)"},
	}

	var found []Service
	for _, svc := range targets {
		if dt.isServiceActive(svc.Name) {
			svc.Active = true
			found = append(found, svc)
		}
	}

	return found
}

// isServiceActive checks if a service is active
func (dt *DebloatTuner) isServiceActive(name string) bool {
	cmd := exec.Command("systemctl", "is-active", name)
	err := cmd.Run()
	return err == nil
}

// Apply disables the identified services
func (dt *DebloatTuner) Apply(backup *BackupManager) error {
	PrintStep("Checking for unnecessary services (Server Slim Mode)")

	services := dt.GetBloatServices()
	if len(services) == 0 {
		PrintSuccess("System is already clean (no bloatware found)")
		return nil
	}

	PrintInfo("Found %d unnecessary services:", len(services))
	for _, svc := range services {
		fmt.Printf("  - %s: %s\n", svc.Name, svc.Description)
	}

	if dt.DryRun {
		PrintInfo("Would disable these services")
		return nil
	}

	// Ask for confirmation if not already confirmed in main
	// For now, we assume the user opted-in via flag or interactive prompt in main

	// Backup services first
	var serviceNames []string
	for _, svc := range services {
		serviceNames = append(serviceNames, svc.Name)
	}
	if err := backup.BackupServices(serviceNames); err != nil {
		PrintWarning("Failed to backup service list: %v", err)
	}

	for _, svc := range services {
		PrintInfo("Disabling %s...", svc.Name)
		
		// Stop
		exec.Command("systemctl", "stop", svc.Name).Run()
		
		// Disable
		if err := exec.Command("systemctl", "disable", svc.Name).Run(); err != nil {
			PrintWarning("Failed to disable %s: %v", svc.Name, err)
		} else {
			PrintSuccess("Disabled %s", svc.Name)
		}
	}

	return nil
}

// DisableServices disables a specific list of services
func (dt *DebloatTuner) DisableServices(services []Service, backup *BackupManager) error {
	// Backup services first
	var serviceNames []string
	for _, svc := range services {
		serviceNames = append(serviceNames, svc.Name)
	}
	if err := backup.BackupServices(serviceNames); err != nil {
		PrintWarning("Failed to backup service list: %v", err)
	}

	for _, svc := range services {
		PrintInfo("Disabling %s...", svc.Name)
		
		if dt.DryRun {
			continue
		}
		
		// Stop
		exec.Command("systemctl", "stop", svc.Name).Run()
		
		// Disable
		if err := exec.Command("systemctl", "disable", svc.Name).Run(); err != nil {
			PrintWarning("Failed to disable %s: %v", svc.Name, err)
		} else {
			PrintSuccess("Disabled %s", svc.Name)
		}
	}
	return nil
}


==========================================
FICHIER : internal\tuner\disk.go
==========================================
package tuner

import (
	"fmt"
	"os/exec"
	"strings"
)

// DiskTuner handles disk expansion
type DiskTuner struct {
	Distro *DistroManager
}

// NewDiskTuner creates a new disk tuner
func NewDiskTuner(distro *DistroManager) *DiskTuner {
	return &DiskTuner{
		Distro: distro,
	}
}

// ExpandRoot expands the root partition and filesystem
func (dt *DiskTuner) ExpandRoot() error {
	PrintStep("Disk Expansion Assistant")

	PrintWarning("âš ï¸  WARNING: Disk operations carry a risk of data loss.")
	PrintWarning("Please ensure you have a snapshot or backup before proceeding.")
	fmt.Println()
	fmt.Print("Do you want to continue? (yes/no): ")
	var response string
	fmt.Scanln(&response)
	if response != "yes" {
		PrintInfo("Operation cancelled")
		return nil
	}

	// 1. Install cloud-guest-utils (contains growpart) if missing
	if err := dt.Distro.InstallPackage("cloud-guest-utils"); err != nil {
		// Try cloud-utils on some distros
		dt.Distro.InstallPackage("cloud-utils")
	}

	// 2. Identify root device
	// This is a simplified approach. In production code, we'd parse lsblk -J
	// For now, we assume standard /dev/sda or /dev/nvme0n1 layout
	
	PrintInfo("Analyzing disk structure...")
	
	// Detect root partition
	cmd := exec.Command("findmnt", "/", "-o", "SOURCE", "-n")
	output, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to detect root device: %w", err)
	}
	rootPart := strings.TrimSpace(string(output))
	PrintInfo("Root partition: %s", rootPart)

	// Detect disk and partition number
	// e.g. /dev/sda2 -> disk=/dev/sda, part=2
	var disk, partNum string
	
	if strings.Contains(rootPart, "nvme") {
		// nvme0n1p2 -> disk=/dev/nvme0n1, part=2
		// Find the last 'p' followed by digits
		lastP := strings.LastIndex(rootPart, "p")
		if lastP > 0 && lastP < len(rootPart)-1 {
			disk = rootPart[:lastP]
			partNum = rootPart[lastP+1:]
		} else {
			return fmt.Errorf("could not parse NVMe partition: %s", rootPart)
		}
	} else {
		// /dev/sda2
		// Very basic parsing, assumes single digit partition for now
		// Better: find last digit sequence
		lastDigitIdx := -1
		for i := len(rootPart) - 1; i >= 0; i-- {
			if rootPart[i] >= '0' && rootPart[i] <= '9' {
				lastDigitIdx = i
			} else {
				break
			}
		}
		
		if lastDigitIdx == -1 {
			return fmt.Errorf("unsupported partition format: %s", rootPart)
		}
		
		// If the partition ends with digits, split there.
		// Actually, for /dev/sda2, we want to split at the last non-digit.
		// Let's stick to the simple logic for sdX for now but make it slightly more robust
		// Find where the digits start at the end
		i := len(rootPart) - 1
		for i >= 0 && (rootPart[i] >= '0' && rootPart[i] <= '9') {
			i--
		}
		// i is now the index of the last non-digit char (e.g. 'a' in sda2)
		if i < 0 || i == len(rootPart)-1 {
			return fmt.Errorf("unsupported partition format: %s", rootPart)
		}
		
		disk = rootPart[:i+1]
		partNum = rootPart[i+1:]
	}

	PrintInfo("Target Disk: %s, Partition: %s", disk, partNum)

	// 3. Grow Partition
	PrintInfo("Extending partition...")
	cmd = exec.Command("growpart", disk, partNum)
	if out, err := cmd.CombinedOutput(); err != nil {
		// Exit code 1 means "no change needed" usually, but let's be careful
		if strings.Contains(string(out), "NOCHANGE") {
			PrintSuccess("Partition is already at max size")
		} else {
			return fmt.Errorf("growpart failed: %v\nOutput: %s", err, string(out))
		}
	} else {
		PrintSuccess("Partition extended")
	}

	// 4. Resize Filesystem
	PrintInfo("Resizing filesystem...")
	
	// Check filesystem type
	cmd = exec.Command("findmnt", "/", "-o", "FSTYPE", "-n")
	out, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to detect fs type: %w", err)
	}
	fsType := strings.TrimSpace(string(out))
	PrintInfo("Filesystem: %s", fsType)

	if fsType == "ext4" {
		cmd = exec.Command("resize2fs", rootPart)
	} else if fsType == "xfs" {
		cmd = exec.Command("xfs_growfs", "/")
	} else {
		return fmt.Errorf("unsupported filesystem: %s", fsType)
	}

	if out, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("resize failed: %v\nOutput: %s", err, string(out))
	}

	PrintSuccess("Filesystem resized successfully!")
	
	// Show new size
	exec.Command("df", "-h", "/").Run()

	return nil
}


==========================================
FICHIER : internal\tuner\distro.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// DistroType represents the Linux distribution family
type DistroType int

const (
	DistroUnknown DistroType = iota
	DistroDebian             // Debian, Ubuntu, Kali, Mint
	DistroRHEL               // RHEL, CentOS, Fedora, AlmaLinux, Rocky
)

// DistroManager handles distribution-specific operations
type DistroManager struct {
	Type DistroType
	Name string
}

// NewDistroManager creates a new distribution manager
func NewDistroManager() (*DistroManager, error) {
	dm := &DistroManager{
		Type: DistroUnknown,
	}

	if err := dm.detect(); err != nil {
		return nil, err
	}

	return dm, nil
}

// detect determines the running Linux distribution
func (dm *DistroManager) detect() error {
	data, err := os.ReadFile("/etc/os-release")
	if err != nil {
		return fmt.Errorf("failed to read /etc/os-release: %w", err)
	}

	content := string(data)
	contentLower := strings.ToLower(content)

	if strings.Contains(contentLower, "debian") || strings.Contains(contentLower, "ubuntu") {
		dm.Type = DistroDebian
		dm.Name = "Debian/Ubuntu"
	} else if strings.Contains(contentLower, "rhel") || strings.Contains(contentLower, "centos") || 
		strings.Contains(contentLower, "fedora") || strings.Contains(contentLower, "almalinux") || 
		strings.Contains(contentLower, "rocky") {
		dm.Type = DistroRHEL
		dm.Name = "RHEL/CentOS"
	} else {
		// Fallback: check for package managers
		if _, err := exec.LookPath("apt-get"); err == nil {
			dm.Type = DistroDebian
			dm.Name = "Debian-based"
		} else if _, err := exec.LookPath("yum"); err == nil {
			dm.Type = DistroRHEL
			dm.Name = "RHEL-based"
		} else if _, err := exec.LookPath("dnf"); err == nil {
			dm.Type = DistroRHEL
			dm.Name = "RHEL-based"
		} else {
			return fmt.Errorf("unsupported distribution")
		}
	}

	return nil
}

// InstallPackage installs a package using the system package manager
func (dm *DistroManager) InstallPackage(pkg string) error {
	var cmd *exec.Cmd

	switch dm.Type {
	case DistroDebian:
		// Update apt cache first? Maybe too slow. Just try install.
		// apt-get install -y <pkg>
		cmd = exec.Command("apt-get", "install", "-y", pkg)
	case DistroRHEL:
		// dnf install -y <pkg> (or yum)
		if _, err := exec.LookPath("dnf"); err == nil {
			cmd = exec.Command("dnf", "install", "-y", pkg)
		} else {
			cmd = exec.Command("yum", "install", "-y", pkg)
		}
	default:
		return fmt.Errorf("unknown distribution type")
	}

	PrintInfo("Installing package %s...", pkg)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to install %s: %v\nOutput: %s", pkg, err, string(output))
	}

	PrintSuccess("Installed %s", pkg)
	return nil
}

// UpdateGrub updates the GRUB configuration
func (dm *DistroManager) UpdateGrub() error {
	switch dm.Type {
	case DistroDebian:
		cmd := exec.Command("update-grub")
		output, err := cmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("update-grub failed: %v\nOutput: %s", err, string(output))
		}
		return nil

	case DistroRHEL:
		// Detect correct output path for grub2-mkconfig
		outputPath := "/boot/grub2/grub.cfg"
		
		// Check for UEFI
		if _, err := os.Stat("/sys/firmware/efi"); err == nil {
			// UEFI detected
			// RHEL 7/8/9 location variations
			// Common paths: /boot/efi/EFI/redhat/grub.cfg, /boot/efi/EFI/centos/grub.cfg
			
			// Try to find the correct path
			candidates := []string{
				"/boot/efi/EFI/redhat/grub.cfg",
				"/boot/efi/EFI/centos/grub.cfg",
				"/boot/efi/EFI/almalinux/grub.cfg",
				"/boot/efi/EFI/rocky/grub.cfg",
				"/boot/efi/EFI/fedora/grub.cfg",
			}
			
			found := false
			for _, path := range candidates {
				if _, err := os.Stat(path); err == nil {
					outputPath = path
					found = true
					break
				}
			}
			
			// On newer RHEL (9.3+), /boot/grub2/grub.cfg might be the unified location even for EFI
			// If no specific EFI file found, stick to /boot/grub2/grub.cfg or try to detect if it's a symlink?
			// For now, if not found in EFI partition, default to /boot/grub2/grub.cfg
			if !found {
				PrintWarning("Could not detect specific EFI GRUB path, defaulting to %s", outputPath)
			}
		}

		PrintInfo("Updating GRUB config at %s...", outputPath)
		cmd := exec.Command("grub2-mkconfig", "-o", outputPath)
		output, err := cmd.CombinedOutput()
		if err != nil {
			return fmt.Errorf("grub2-mkconfig failed: %v\nOutput: %s", err, string(output))
		}
		return nil

	default:
		return fmt.Errorf("unsupported distribution for GRUB update")
	}
}

// GetGrubConfigPath returns the path to the GRUB configuration file
func (dm *DistroManager) GetGrubConfigPath() string {
	// Usually /etc/default/grub for both
	return "/etc/default/grub"
}


==========================================
FICHIER : internal\tuner\docker.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// DockerTuner handles Docker optimization
type DockerTuner struct{}

// NewDockerTuner creates a new docker tuner
func NewDockerTuner() *DockerTuner {
	return &DockerTuner{}
}

// Run performs the optimization
func (dt *DockerTuner) Run() error {
	PrintStep("Docker Optimizer")

	// 1. Check if Docker is installed
	if _, err := exec.LookPath("docker"); err != nil {
		PrintWarning("Docker is not installed.")
		return nil
	}
	PrintSuccess("Docker is installed")

	// 2. Check Log Rotation
	daemonFile := "/etc/docker/daemon.json"
	needsRotation := true

	if _, err := os.Stat(daemonFile); err == nil {
		content, _ := os.ReadFile(daemonFile)
		if strings.Contains(string(content), "log-driver") && strings.Contains(string(content), "max-size") {
			PrintSuccess("Log rotation is already configured")
			needsRotation = false
		}
	}

	if needsRotation {
		PrintWarning("Docker log rotation is NOT configured.")
		PrintInfo("Containers can fill the disk with logs.")
		fmt.Print("Configure log rotation (max-size=10m, max-file=3)? (y/n): ")
		var resp string
		fmt.Scanln(&resp)
		if resp == "y" {
			// Create or update daemon.json
			// Simple overwrite if not exists, or append warning if complex
			if _, err := os.Stat(daemonFile); os.IsNotExist(err) {
				content := `{
  "log-driver": "json-file",
  "log-opts": {
    "max-size": "10m",
    "max-file": "3"
  }
}
`
				if err := os.WriteFile(daemonFile, []byte(content), 0644); err != nil {
					PrintWarning("Failed to write daemon.json: %v", err)
				} else {
					PrintSuccess("Configuration created. Restart Docker to apply.")
					exec.Command("systemctl", "restart", "docker").Run()
				}
			} else {
				PrintWarning("daemon.json exists. Please add log-opts manually to avoid overwriting custom config.")
			}
		}
	}

	// 3. Prune
	fmt.Println()
	PrintInfo("Docker System Prune")
	PrintInfo("This will remove:")
	PrintInfo("  - Stopped containers")
	PrintInfo("  - Unused networks")
	PrintInfo("  - Dangling images")
	PrintInfo("  - Build cache")
	fmt.Print("Run prune? (y/n): ")
	var resp string
	fmt.Scanln(&resp)
	if resp == "y" {
		cmd := exec.Command("docker", "system", "prune", "-f")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			PrintWarning("Prune failed: %v", err)
		} else {
			PrintSuccess("System pruned")
		}
	}

	return nil
}


==========================================
FICHIER : internal\tuner\fstab.go
==========================================
package tuner

import (
	"bufio"
	"fmt"
	"os"
	"os/exec"
	"regexp"
	"strings"
)

// FstabTuner handles /etc/fstab optimization
type FstabTuner struct {
	FstabPath string
	DryRun    bool
}

// NewFstabTuner creates a new fstab tuner
func NewFstabTuner(dryRun bool) *FstabTuner {
	return &FstabTuner{
		FstabPath: "/etc/fstab",
		DryRun:    dryRun,
	}
}

// FstabEntry represents a line in /etc/fstab
type FstabEntry struct {
	Device     string
	MountPoint string
	FSType     string
	Options    []string
	Dump       string
	Pass       string
	Comment    string
	IsComment  bool
}

// ParseFstab parses /etc/fstab and returns entries
func (ft *FstabTuner) ParseFstab() ([]FstabEntry, error) {
	file, err := os.Open(ft.FstabPath)
	if err != nil {
		return nil, fmt.Errorf("failed to open %s: %w", ft.FstabPath, err)
	}
	defer file.Close()

	var entries []FstabEntry
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		trimmed := strings.TrimSpace(line)

		// Handle comments and empty lines
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			entries = append(entries, FstabEntry{
				Comment:   line,
				IsComment: true,
			})
			continue
		}

		// Parse fstab entry
		fields := regexp.MustCompile(`\s+`).Split(trimmed, -1)
		if len(fields) < 4 {
			// Malformed line, keep as comment
			entries = append(entries, FstabEntry{
				Comment:   line,
				IsComment: true,
			})
			continue
		}

		entry := FstabEntry{
			Device:     fields[0],
			MountPoint: fields[1],
			FSType:     fields[2],
			Options:    strings.Split(fields[3], ","),
			IsComment:  false,
		}

		if len(fields) > 4 {
			entry.Dump = fields[4]
		} else {
			entry.Dump = "0"
		}

		if len(fields) > 5 {
			entry.Pass = fields[5]
		} else {
			entry.Pass = "0"
		}

		entries = append(entries, entry)
	}

	if err := scanner.Err(); err != nil {
		return nil, fmt.Errorf("error reading fstab: %w", err)
	}

	return entries, nil
}

// OptimizeEntry optimizes mount options for a given entry
func (ft *FstabTuner) OptimizeEntry(entry *FstabEntry) bool {
	// Only optimize ext4 filesystems
	if entry.FSType != "ext4" {
		return false
	}

	// Skip swap and special filesystems
	if entry.MountPoint == "none" || entry.FSType == "swap" {
		return false
	}

	modified := false
	options := make(map[string]bool)

	// Parse existing options
	for _, opt := range entry.Options {
		options[opt] = true
	}

	// Remove discard if present (VMware doesn't support it)
	if options["discard"] {
		delete(options, "discard")
		modified = true
	}

	// Add performance options if not present
	performanceOpts := []string{"noatime", "nodiratime"}
	for _, opt := range performanceOpts {
		if !options[opt] {
			options[opt] = true
			modified = true
		}
	}

	// Add commit=60 if not present
	hasCommit := false
	for opt := range options {
		if strings.HasPrefix(opt, "commit=") {
			hasCommit = true
			break
		}
	}
	if !hasCommit {
		options["commit=60"] = true
		modified = true
	}

	// Rebuild options slice
	if modified {
		newOptions := []string{}
		for opt := range options {
			newOptions = append(newOptions, opt)
		}
		entry.Options = newOptions
	}

	return modified
}

// Apply applies fstab optimizations
func (ft *FstabTuner) Apply(backup *BackupManager) error {
	PrintStep("Optimizing /etc/fstab")

	// Parse current fstab
	entries, err := ft.ParseFstab()
	if err != nil {
		return err
	}

	// Optimize entries
	modified := false
	for i := range entries {
		if !entries[i].IsComment {
			if ft.OptimizeEntry(&entries[i]) {
				modified = true
				PrintInfo("Optimizing: %s mounted at %s",
					entries[i].Device, entries[i].MountPoint)
			}
		}
	}

	if !modified {
		PrintSuccess("No fstab optimizations needed")
		return nil
	}

	// Generate new fstab content
	newContent := ft.GenerateFstab(entries)

	if ft.DryRun {
		PrintInfo("Would update: %s", ft.FstabPath)
		PrintInfo("New content preview:")
		fmt.Println(newContent)
		return nil
	}

	// Backup existing fstab
	if err := backup.BackupFile(ft.FstabPath); err != nil {
		return fmt.Errorf("failed to backup fstab: %w", err)
	}

	// Write new fstab
	if err := os.WriteFile(ft.FstabPath, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("failed to write fstab: %w", err)
	}

	PrintSuccess("Updated %s", ft.FstabPath)

	// Remount filesystems with new options
	PrintInfo("Remounting filesystems...")
	for _, entry := range entries {
		if !entry.IsComment && entry.FSType == "ext4" && entry.MountPoint != "none" {
			if err := ft.RemountFilesystem(entry.MountPoint); err != nil {
				PrintWarning("Failed to remount %s: %v", entry.MountPoint, err)
				PrintWarning("A reboot may be required for changes to take effect")
			} else {
				PrintSuccess("Remounted %s", entry.MountPoint)
			}
		}
	}

	return nil
}

// GenerateFstab generates fstab content from entries
func (ft *FstabTuner) GenerateFstab(entries []FstabEntry) string {
	var lines []string

	for _, entry := range entries {
		if entry.IsComment {
			lines = append(lines, entry.Comment)
			continue
		}

		// Format the entry
		optionsStr := strings.Join(entry.Options, ",")
		line := fmt.Sprintf("%-45s %-15s %-7s %-30s %s %s",
			entry.Device,
			entry.MountPoint,
			entry.FSType,
			optionsStr,
			entry.Dump,
			entry.Pass)

		lines = append(lines, line)
	}

	return strings.Join(lines, "\n") + "\n"
}

// RemountFilesystem remounts a filesystem with new options
func (ft *FstabTuner) RemountFilesystem(mountPoint string) error {
	cmd := exec.Command("mount", "-o", "remount", mountPoint)
	if output, err := cmd.CombinedOutput(); err != nil {
		return fmt.Errorf("%s: %w", string(output), err)
	}
	return nil
}

// ShowCurrent displays current fstab configuration
func (ft *FstabTuner) ShowCurrent() error {
	PrintStep("Current /etc/fstab entries")

	entries, err := ft.ParseFstab()
	if err != nil {
		return err
	}

	for _, entry := range entries {
		if entry.IsComment {
			continue
		}

		fmt.Printf("\n  Mount: %s\n", entry.MountPoint)
		fmt.Printf("  Device: %s\n", entry.Device)
		fmt.Printf("  Type: %s\n", entry.FSType)
		fmt.Printf("  Options: %s\n", strings.Join(entry.Options, ","))
	}

	return nil
}


==========================================
FICHIER : internal\tuner\grub.go
==========================================
package tuner

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strings"
)

// GrubTuner handles GRUB boot parameter optimization
type GrubTuner struct {
	GrubPath string
	DryRun   bool
	Distro   *DistroManager
}

// NewGrubTuner creates a new GRUB tuner
func NewGrubTuner(dryRun bool, distro *DistroManager) *GrubTuner {
	path := "/etc/default/grub"
	if distro != nil {
		path = distro.GetGrubConfigPath()
	}
	
	return &GrubTuner{
		GrubPath: path,
		DryRun:   dryRun,
		Distro:   distro,
	}
}

// VMwareBootParams returns optimal boot parameters for VMware VMs
func (gt *GrubTuner) VMwareBootParams() []string {
	return []string{
		"elevator=noop",                    // I/O scheduler for VMs
		"transparent_hugepage=madvise",     // Reduce memory fragmentation
		"vsyscall=emulate",                 // VMware compatibility
		"clocksource=tsc",                  // Use TSC for time
		"tsc=reliable",                     // Trust TSC
		"intel_idle.max_cstate=0",          // Disable deep C-states
		"processor.max_cstate=1",           // Keep CPU responsive
		"nmi_watchdog=0",                   // Disable NMI watchdog (save CPU)
		"pcie_aspm=off",                    // Disable PCIe power management
		"nvme_core.default_ps_max_latency_us=0", // Disable NVMe power save
	}
}

// ParseGrubConfig parses GRUB configuration
func (gt *GrubTuner) ParseGrubConfig() (map[string]string, []string, error) {
	file, err := os.Open(gt.GrubPath)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to open %s: %w", gt.GrubPath, err)
	}
	defer file.Close()

	config := make(map[string]string)
	var lines []string
	scanner := bufio.NewScanner(file)

	for scanner.Scan() {
		line := scanner.Text()
		lines = append(lines, line)

		// Parse key=value pairs
		if strings.HasPrefix(strings.TrimSpace(line), "#") || !strings.Contains(line, "=") {
			continue
		}

		// Match GRUB_* variables
		re := regexp.MustCompile(`^([A-Z_]+)=(.*)$`)
		matches := re.FindStringSubmatch(strings.TrimSpace(line))
		if len(matches) == 3 {
			key := matches[1]
			value := strings.Trim(matches[2], `"`)
			config[key] = value
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, nil, fmt.Errorf("error reading grub config: %w", err)
	}

	return config, lines, nil
}

// Apply applies GRUB optimizations
func (gt *GrubTuner) Apply(backup *BackupManager) error {
	PrintStep("Optimizing GRUB boot parameters")

	// Parse current GRUB config
	config, lines, err := gt.ParseGrubConfig()
	if err != nil {
		return err
	}

	// Get current cmdline
	currentCmdline := config["GRUB_CMDLINE_LINUX_DEFAULT"]
	currentParams := gt.parseParams(currentCmdline)

	// Get VMware optimal params
	vmwareParams := gt.VMwareBootParams()

	// Merge parameters
	newParams := gt.mergeParams(currentParams, vmwareParams)
	newCmdline := strings.Join(newParams, " ")

	// Check if modification is needed
	if currentCmdline == newCmdline {
		PrintSuccess("GRUB boot parameters already optimized")
		return nil
	}

	PrintInfo("Current cmdline: %s", currentCmdline)
	PrintInfo("New cmdline: %s", newCmdline)

	if gt.DryRun {
		PrintInfo("Would update: %s", gt.GrubPath)
		return nil
	}

	// Backup existing GRUB config
	if err := backup.BackupFile(gt.GrubPath); err != nil {
		return fmt.Errorf("failed to backup grub config: %w", err)
	}

	// Update GRUB configuration
	newLines := gt.updateGrubLines(lines, newCmdline)
	newContent := strings.Join(newLines, "\n") + "\n"

	if err := os.WriteFile(gt.GrubPath, []byte(newContent), 0644); err != nil {
		return fmt.Errorf("failed to write grub config: %w", err)
	}

	PrintSuccess("Updated %s", gt.GrubPath)

	// Run update-grub
	PrintInfo("Updating GRUB configuration...")
	if err := gt.Distro.UpdateGrub(); err != nil {
		PrintWarning("Failed to update GRUB: %v", err)
		return fmt.Errorf("grub update failed: %w", err)
	}

	PrintSuccess("GRUB configuration updated")
	PrintWarning("REBOOT REQUIRED for boot parameter changes to take effect")

	return nil
}

// parseParams parses a space-separated parameter string
func (gt *GrubTuner) parseParams(cmdline string) []string {
	if cmdline == "" {
		return []string{}
	}

	// Split by whitespace
	params := strings.Fields(cmdline)
	return params
}

// mergeParams merges existing and new parameters
func (gt *GrubTuner) mergeParams(existing, new []string) []string {
	// Create a map to track parameter keys
	paramMap := make(map[string]string)

	// Extract key from param (handle key=value and standalone params)
	getKey := func(param string) string {
		if idx := strings.Index(param, "="); idx != -1 {
			return param[:idx]
		}
		return param
	}

	// Add existing params
	for _, param := range existing {
		key := getKey(param)
		paramMap[key] = param
	}

	// Add/override with new params
	for _, param := range new {
		key := getKey(param)
		paramMap[key] = param
	}

	// Convert back to slice
	var result []string
	for _, param := range paramMap {
		result = append(result, param)
	}

	return result
}

// updateGrubLines updates GRUB_CMDLINE_LINUX_DEFAULT in the config lines
func (gt *GrubTuner) updateGrubLines(lines []string, newCmdline string) []string {
	var newLines []string
	re := regexp.MustCompile(`^GRUB_CMDLINE_LINUX_DEFAULT=`)

	for _, line := range lines {
		if re.MatchString(strings.TrimSpace(line)) {
			newLines = append(newLines, fmt.Sprintf(`GRUB_CMDLINE_LINUX_DEFAULT="%s"`, newCmdline))
		} else {
			newLines = append(newLines, line)
		}
	}

	return newLines
}

// ShowCurrent displays current boot parameters
func (gt *GrubTuner) ShowCurrent() error {
	PrintStep("Current GRUB configuration")

	config, _, err := gt.ParseGrubConfig()
	if err != nil {
		return err
	}

	cmdline := config["GRUB_CMDLINE_LINUX_DEFAULT"]
	params := gt.parseParams(cmdline)

	fmt.Printf("  GRUB_CMDLINE_LINUX_DEFAULT=\"%s\"\n\n", cmdline)
	fmt.Println("  Boot parameters:")
	for _, param := range params {
		fmt.Printf("    - %s\n", param)
	}

	// Also show current running kernel parameters
	PrintStep("Current running kernel parameters")
	data, err := os.ReadFile("/proc/cmdline")
	if err != nil {
		return err
	}

	fmt.Printf("  %s\n", strings.TrimSpace(string(data)))

	return nil
}


==========================================
FICHIER : internal\tuner\hardware.go
==========================================
package tuner

import (
	"os/exec"
	"strings"
)

// HardwareTuner handles hardware verification
type HardwareTuner struct {
	Distro *DistroManager
}

// NewHardwareTuner creates a new hardware tuner
func NewHardwareTuner(distro *DistroManager) *HardwareTuner {
	return &HardwareTuner{
		Distro: distro,
	}
}

// Run performs the hardware check
func (ht *HardwareTuner) Run() error {
	PrintStep("Virtual Hardware Inspector")

	// 1. Check Network Adapter Type
	PrintInfo("Checking Network Adapter...")
	// Get interface name
	cmd := exec.Command("ip", "-o", "link", "show")
	out, err := cmd.Output()
	if err == nil {
		lines := strings.Split(string(out), "\n")
		foundVmxnet3 := false
		for _, line := range lines {
			if strings.Contains(line, "link/ether") {
				parts := strings.Fields(line)
				if len(parts) > 1 {
					iface := strings.Trim(parts[1], ":")
					// Check driver
					driverCmd := exec.Command("ethtool", "-i", iface)
					driverOut, _ := driverCmd.Output()
					if strings.Contains(string(driverOut), "driver: vmxnet3") {
						foundVmxnet3 = true
						PrintSuccess("Interface %s is using vmxnet3 driver", iface)
					} else if strings.Contains(string(driverOut), "driver: e1000") {
						PrintWarning("Interface %s is using legacy e1000 driver (Upgrade to vmxnet3 recommended)", iface)
					}
				}
			}
		}
		if !foundVmxnet3 {
			PrintInfo("No vmxnet3 adapters found (or ethtool missing)")
		}
	}

	// 2. Check SCSI Controller
	PrintInfo("Checking SCSI Controller...")
	// lspci is best, but might not be installed.
	// Try installing pciutils if missing? No, read-only check shouldn't install stuff ideally.
	// Let's try to detect via sysfs or dmesg
	
	// Check for vmw_pvscsi or nvme module
	if out, err := exec.Command("lsmod").Output(); err == nil {
		output := string(out)
		if strings.Contains(output, "vmw_pvscsi") {
			PrintSuccess("VMware Paravirtual SCSI (PVSCSI) driver loaded")
		} else if strings.Contains(output, "nvme") {
			PrintSuccess("NVMe Controller detected (High Performance)")
		} else if strings.Contains(output, "mptspi") || strings.Contains(output, "mptsas") {
			PrintInfo("Detected LSI Logic Controller (Standard)")
			PrintInfo("Recommendation: Upgrade to VMware Paravirtual (PVSCSI) for better I/O performance")
		} else {
			// Check if it's built-in or just not used
			PrintWarning("Optimal Storage Controller not found (PVSCSI/NVMe)")
		}
	}

	// 3. Check 3D Acceleration (often unnecessary on servers)
	// Hard to check from guest without logs, skip for now.

	return nil
}


==========================================
FICHIER : internal\tuner\info.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// InfoTuner handles system info display
type InfoTuner struct{}

// NewInfoTuner creates a new info tuner
func NewInfoTuner() *InfoTuner {
	return &InfoTuner{}
}

// Run displays the info
func (it *InfoTuner) Run() error {
	PrintStep("System Information")

	// 1. OS Info
	osInfo := "Unknown"
	if data, err := os.ReadFile("/etc/os-release"); err == nil {
		lines := strings.Split(string(data), "\n")
		for _, line := range lines {
			if strings.HasPrefix(line, "PRETTY_NAME=") {
				osInfo = strings.Trim(line[12:], "\"")
				break
			}
		}
	}
	fmt.Printf("  %-20s: %s\n", "OS", osInfo)

	// 2. Kernel
	if out, err := exec.Command("uname", "-r").Output(); err == nil {
		fmt.Printf("  %-20s: %s", "Kernel", string(out))
	}

	// 3. CPU
	// grep -c processor /proc/cpuinfo
	if out, err := exec.Command("bash", "-c", "grep -c processor /proc/cpuinfo").Output(); err == nil {
		fmt.Printf("  %-20s: %s", "vCPUs", string(out))
	}

	// 4. Memory
	// free -h | grep Mem | awk '{print $2}'
	if out, err := exec.Command("bash", "-c", "free -h | grep Mem").Output(); err == nil {
		parts := strings.Fields(string(out))
		if len(parts) >= 3 {
			fmt.Printf("  %-20s: %s (Used: %s)\n", "Memory", parts[1], parts[2])
		}
	}

	// 5. IP Address
	// hostname -I | awk '{print $1}'
	if out, err := exec.Command("hostname", "-I").Output(); err == nil {
		ips := strings.TrimSpace(string(out))
		firstIp := strings.Split(ips, " ")[0]
		fmt.Printf("  %-20s: %s\n", "IP Address", firstIp)
	}

	// 6. VM Tools Status
	fmt.Printf("  %-20s: ", "VMware Tools")
	if err := exec.Command("systemctl", "is-active", "vmtoolsd").Run(); err == nil {
		PrintSuccess("Running")
	} else {
		PrintWarning("Not Running")
	}

	return nil
}


==========================================
FICHIER : internal\tuner\logdoctor.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// LogDoctorTuner handles log scanning
type LogDoctorTuner struct {
	Distro *DistroManager
}

// NewLogDoctorTuner creates a new log doctor
func NewLogDoctorTuner(distro *DistroManager) *LogDoctorTuner {
	return &LogDoctorTuner{
		Distro: distro,
	}
}

// Run performs the log scan
func (ld *LogDoctorTuner) Run() error {
	PrintStep("Log Doctor (Troubleshoot)")

	keywords := []string{
		"Out of memory",
		"Kill process",
		"I/O error",
		"SCSI error",
		"Call Trace",
		"soft lockup",
		"segfault",
		"EXT4-fs error",
		"XFS_WANT_CORRUPT",
	}

	foundIssues := false

	// 1. Check dmesg (Kernel Ring Buffer)
	PrintInfo("Scanning kernel ring buffer (dmesg)...")
	out, err := exec.Command("dmesg").Output()
	if err == nil {
		lines := strings.Split(string(out), "\n")
		// Check last 1000 lines to avoid noise from boot time if uptime is long
		start := 0
		if len(lines) > 1000 {
			start = len(lines) - 1000
		}
		
		for i := start; i < len(lines); i++ {
			line := lines[i]
			for _, kw := range keywords {
				if strings.Contains(line, kw) {
					PrintWarning("Found in dmesg: %s", line)
					foundIssues = true
				}
			}
		}
	}

	// 2. Check System Log
	logFile := "/var/log/syslog"
	if ld.Distro.Type == DistroRHEL {
		logFile = "/var/log/messages"
	}

	PrintInfo("Scanning system log (%s)...", logFile)
	if _, err := os.Stat(logFile); err == nil {
		// Use grep for efficiency
		for _, kw := range keywords {
			// grep -i "keyword" /var/log/syslog | tail -n 5
			cmd := exec.Command("bash", "-c", fmt.Sprintf("grep -i \"%s\" %s | tail -n 5", kw, logFile))
			out, err := cmd.Output()
			if err == nil && len(out) > 0 {
				PrintWarning("Found '%s' errors:", kw)
				fmt.Println(string(out))
				foundIssues = true
			}
		}
	} else {
		PrintInfo("Log file not found: %s", logFile)
	}

	if !foundIssues {
		PrintSuccess("No critical errors found in recent logs.")
	} else {
		fmt.Println()
		PrintInfo("Issues were found. Please investigate the logs further.")
	}

	return nil
}


==========================================
FICHIER : internal\tuner\network.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// NetworkTuner handles network optimization
type NetworkTuner struct {
	ServicePath string
	DryRun      bool
}

// NewNetworkTuner creates a new network tuner
func NewNetworkTuner(dryRun bool) *NetworkTuner {
	return &NetworkTuner{
		ServicePath: "/etc/systemd/system/network-tuning.service",
		DryRun:      dryRun,
	}
}

// GetSystemdService returns the systemd service for network tuning
func (nt *NetworkTuner) GetSystemdService() string {
	return `[Unit]
Description=Network Performance Tuning for VMware
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
RemainOnExit=yes

# Increase ring buffers (ONLY for vmxnet3 to avoid e1000 hangs)
ExecStart=/bin/bash -c 'for iface in $(ls /sys/class/net/ | grep -E "^(ens|eth)"); do if ethtool -i $iface | grep -q "driver: vmxnet3"; then ethtool -G $iface rx 4096 tx 4096 2>/dev/null || true; fi; done'

# Enable hardware offloading features (ONLY for vmxnet3)
ExecStart=/bin/bash -c 'for iface in $(ls /sys/class/net/ | grep -E "^(ens|eth)"); do if ethtool -i $iface | grep -q "driver: vmxnet3"; then ethtool -K $iface gso on gro on tso on 2>/dev/null || true; fi; done'

# Set interrupt coalescing (ONLY for vmxnet3)
ExecStart=/bin/bash -c 'for iface in $(ls /sys/class/net/ | grep -E "^(ens|eth)"); do if ethtool -i $iface | grep -q "driver: vmxnet3"; then ethtool -C $iface rx-usecs 10 tx-usecs 10 2>/dev/null || true; fi; done'

[Install]
WantedBy=multi-user.target
`
}

// Apply applies network optimizations
func (nt *NetworkTuner) Apply(backup *BackupManager) error {
	PrintStep("Configuring network optimizations")

	service := nt.GetSystemdService()

	if nt.DryRun {
		PrintInfo("Would create: %s", nt.ServicePath)
		PrintInfo("Service file preview:")
		fmt.Println(service)
		return nil
	}

	// Backup existing service if it exists
	if err := backup.BackupFile(nt.ServicePath); err != nil {
		return fmt.Errorf("failed to backup network service: %w", err)
	}

	// Write systemd service
	if err := os.WriteFile(nt.ServicePath, []byte(service), 0644); err != nil {
		return fmt.Errorf("failed to write network service: %w", err)
	}

	PrintSuccess("Created %s", nt.ServicePath)

	// Reload systemd
	PrintInfo("Reloading systemd daemon...")
	cmd := exec.Command("systemctl", "daemon-reload")
	if output, err := cmd.CombinedOutput(); err != nil {
		PrintWarning("Failed to reload systemd: %v", err)
		fmt.Println(string(output))
	}

	// Enable the service
	PrintInfo("Enabling network tuning service...")
	cmd = exec.Command("systemctl", "enable", "network-tuning.service")
	if output, err := cmd.CombinedOutput(); err != nil {
		PrintWarning("Failed to enable service: %v", err)
		fmt.Println(string(output))
	}

	// Start the service (apply changes now)
	PrintInfo("Starting network tuning service...")
	cmd = exec.Command("systemctl", "start", "network-tuning.service")
	if output, err := cmd.CombinedOutput(); err != nil {
		PrintWarning("Failed to start service: %v", err)
		fmt.Println(string(output))
		PrintWarning("Network tuning will be applied on next boot")
	} else {
		PrintSuccess("Network tuning applied immediately")
	}

	return nil
}

// ShowCurrent displays current network settings
func (nt *NetworkTuner) ShowCurrent() error {
	PrintStep("Current network interface settings")

	// Get network interfaces
	interfaces, err := nt.getNetworkInterfaces()
	if err != nil {
		return err
	}

	for _, iface := range interfaces {
		fmt.Printf("\n  Interface: %s\n", iface)

		// Get ring buffer settings
		cmd := exec.Command("ethtool", "-g", iface)
		if output, err := cmd.Output(); err == nil {
			lines := strings.Split(string(output), "\n")
			for _, line := range lines {
				if strings.Contains(line, "Current") || strings.Contains(line, "RX") || strings.Contains(line, "TX") {
					fmt.Printf("    %s\n", strings.TrimSpace(line))
				}
			}
		}

		// Get offload features
		cmd = exec.Command("ethtool", "-k", iface)
		if output, err := cmd.Output(); err == nil {
			features := []string{"tcp-segmentation-offload", "generic-receive-offload", "generic-segmentation-offload"}
			lines := strings.Split(string(output), "\n")
			for _, line := range lines {
				for _, feature := range features {
					if strings.Contains(line, feature+":") {
						fmt.Printf("    %s\n", strings.TrimSpace(line))
					}
				}
			}
		}
	}

	return nil
}

// getNetworkInterfaces returns a list of network interfaces
func (nt *NetworkTuner) getNetworkInterfaces() ([]string, error) {
	cmd := exec.Command("bash", "-c", "ls /sys/class/net/ | grep -E '^(ens|eth)'")
	output, err := cmd.Output()
	if err != nil {
		return nil, fmt.Errorf("failed to get network interfaces: %w", err)
	}

	interfaces := strings.Split(strings.TrimSpace(string(output)), "\n")
	if len(interfaces) == 1 && interfaces[0] == "" {
		return []string{}, nil
	}

	return interfaces, nil
}

// Verify checks if the network tuning service exists
func (nt *NetworkTuner) Verify() error {
	if _, err := os.Stat(nt.ServicePath); os.IsNotExist(err) {
		return fmt.Errorf("network tuning service not found: %s", nt.ServicePath)
	}

	PrintSuccess("Network tuning service exists")

	// Check if service is enabled
	cmd := exec.Command("systemctl", "is-enabled", "network-tuning.service")
	if output, err := cmd.Output(); err == nil {
		status := strings.TrimSpace(string(output))
		if status == "enabled" {
			PrintSuccess("Network tuning service is enabled")
		} else {
			PrintWarning("Network tuning service is not enabled")
		}
	}

	return nil
}


==========================================
FICHIER : internal\tuner\scheduler.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

// SchedulerTuner handles I/O scheduler optimization
type SchedulerTuner struct {
	UdevRulePath string
	DryRun       bool
}

// NewSchedulerTuner creates a new scheduler tuner
func NewSchedulerTuner(dryRun bool) *SchedulerTuner {
	return &SchedulerTuner{
		UdevRulePath: "/etc/udev/rules.d/60-scheduler.rules",
		DryRun:       dryRun,
	}
}

// GetUdevRules returns the udev rules for I/O scheduler
func (st *SchedulerTuner) GetUdevRules() string {
	return `# I/O Scheduler optimization for VMware VMs
# Generated by vmware-tuner

# Use 'none' (or 'noop' on older kernels) for all block devices
# This is optimal for VMs as the hypervisor handles I/O scheduling

# For SSDs and virtual disks (rotational=0)
ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/rotational}=="0", ATTR{queue/scheduler}="none"

# For HDDs (rotational=1) - still use none in VMs
ACTION=="add|change", KERNEL=="sd[a-z]|nvme[0-9]n[0-9]", ATTR{queue/rotational}=="1", ATTR{queue/scheduler}="none"

# VMware PVSCSI devices
ACTION=="add|change", KERNEL=="sd[a-z]", DRIVERS=="vmw_pvscsi", ATTR{queue/scheduler}="none"

# Increase queue depth for better performance
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{queue/nr_requests}="256"
ACTION=="add|change", KERNEL=="nvme[0-9]n[0-9]", ATTR{queue/nr_requests}="256"

# Read-ahead optimization (in KB)
ACTION=="add|change", KERNEL=="sd[a-z]", ATTR{bdi/read_ahead_kb}="256"
ACTION=="add|change", KERNEL=="nvme[0-9]n[0-9]", ATTR{bdi/read_ahead_kb}="256"
`
}

// Apply applies I/O scheduler optimizations
func (st *SchedulerTuner) Apply(backup *BackupManager) error {
	PrintStep("Configuring I/O scheduler")

	rules := st.GetUdevRules()

	if st.DryRun {
		PrintInfo("Would create: %s", st.UdevRulePath)
		PrintInfo("Udev rules preview:")
		fmt.Println(rules)
		return nil
	}

	// Backup existing rules if they exist
	if err := backup.BackupFile(st.UdevRulePath); err != nil {
		return fmt.Errorf("failed to backup udev rules: %w", err)
	}

	// Write udev rules
	if err := os.WriteFile(st.UdevRulePath, []byte(rules), 0644); err != nil {
		return fmt.Errorf("failed to write udev rules: %w", err)
	}

	PrintSuccess("Created %s", st.UdevRulePath)

	// Reload udev rules
	PrintInfo("Reloading udev rules...")
	cmd := exec.Command("udevadm", "control", "--reload-rules")
	if output, err := cmd.CombinedOutput(); err != nil {
		PrintWarning("Failed to reload udev rules: %v", err)
		fmt.Println(string(output))
	} else {
		PrintSuccess("Udev rules reloaded")
	}

	// Apply to current block devices immediately
	if err := st.ApplyToCurrentDevices(); err != nil {
		PrintWarning("Some devices may require a reboot for scheduler changes")
	}

	return nil
}

// ApplyToCurrentDevices applies scheduler changes to currently attached devices
func (st *SchedulerTuner) ApplyToCurrentDevices() error {
	PrintInfo("Applying I/O scheduler to current devices...")

	// Find all block devices
	devices, err := filepath.Glob("/sys/block/sd*")
	if err != nil {
		return err
	}

	nvmeDevices, _ := filepath.Glob("/sys/block/nvme*")
	devices = append(devices, nvmeDevices...)

	successCount := 0
	failCount := 0

	for _, device := range devices {
		deviceName := filepath.Base(device)
		schedulerPath := filepath.Join(device, "queue", "scheduler")

		// Set scheduler to 'none'
		if err := st.setScheduler(schedulerPath, "none"); err != nil {
			// Try 'noop' as fallback (older kernels)
			if err := st.setScheduler(schedulerPath, "noop"); err != nil {
				PrintWarning("Failed to set scheduler for %s: %v", deviceName, err)
				failCount++
				continue
			}
		}

		// Set nr_requests
		nrRequestsPath := filepath.Join(device, "queue", "nr_requests")
		if err := os.WriteFile(nrRequestsPath, []byte("256"), 0644); err != nil {
			// Not critical, just warn
			PrintWarning("Could not set nr_requests for %s", deviceName)
		}

		// Set read_ahead_kb
		readAheadPath := filepath.Join(device, "bdi", "read_ahead_kb")
		if err := os.WriteFile(readAheadPath, []byte("256"), 0644); err != nil {
			// Not critical, just warn
			PrintWarning("Could not set read_ahead_kb for %s", deviceName)
		}

		successCount++
		PrintSuccess("Configured %s", deviceName)
	}

	if successCount > 0 {
		PrintSuccess("Applied I/O scheduler to %d device(s)", successCount)
	}
	if failCount > 0 {
		return fmt.Errorf("failed to configure %d device(s)", failCount)
	}

	return nil
}

// setScheduler sets the I/O scheduler for a device
func (st *SchedulerTuner) setScheduler(schedulerPath, scheduler string) error {
	return os.WriteFile(schedulerPath, []byte(scheduler), 0644)
}

// ShowCurrent displays current I/O scheduler settings
func (st *SchedulerTuner) ShowCurrent() error {
	PrintStep("Current I/O scheduler settings")

	// Find all block devices
	devices, err := filepath.Glob("/sys/block/sd*")
	if err != nil {
		return err
	}

	nvmeDevices, _ := filepath.Glob("/sys/block/nvme*")
	devices = append(devices, nvmeDevices...)

	if len(devices) == 0 {
		PrintWarning("No block devices found")
		return nil
	}

	for _, device := range devices {
		deviceName := filepath.Base(device)
		schedulerPath := filepath.Join(device, "queue", "scheduler")

		data, err := os.ReadFile(schedulerPath)
		if err != nil {
			PrintWarning("Could not read scheduler for %s", deviceName)
			continue
		}

		// Extract current scheduler (marked with [brackets])
		schedulerLine := strings.TrimSpace(string(data))
		current := "unknown"

		// Find scheduler in brackets
		if start := strings.Index(schedulerLine, "["); start != -1 {
			if end := strings.Index(schedulerLine[start:], "]"); end != -1 {
				current = schedulerLine[start+1 : start+end]
			}
		}

		// Get read-ahead value
		readAheadPath := filepath.Join(device, "bdi", "read_ahead_kb")
		readAhead := "N/A"
		if data, err := os.ReadFile(readAheadPath); err == nil {
			readAhead = strings.TrimSpace(string(data)) + " KB"
		}

		// Get queue depth
		nrRequestsPath := filepath.Join(device, "queue", "nr_requests")
		nrRequests := "N/A"
		if data, err := os.ReadFile(nrRequestsPath); err == nil {
			nrRequests = strings.TrimSpace(string(data))
		}

		fmt.Printf("\n  Device: %s\n", deviceName)
		fmt.Printf("  Scheduler: %s\n", current)
		fmt.Printf("  Read-ahead: %s\n", readAhead)
		fmt.Printf("  Queue depth: %s\n", nrRequests)
	}

	return nil
}

// Verify checks if the udev rules have been applied
func (st *SchedulerTuner) Verify() error {
	if _, err := os.Stat(st.UdevRulePath); os.IsNotExist(err) {
		return fmt.Errorf("udev rules file not found: %s", st.UdevRulePath)
	}

	PrintSuccess("I/O scheduler udev rules exist")
	return nil
}


==========================================
FICHIER : internal\tuner\ssh.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// SSHTuner handles SSH hardening
type SSHTuner struct {
	Backup *BackupManager
}

// NewSSHTuner creates a new SSH tuner
func NewSSHTuner(backup *BackupManager) *SSHTuner {
	return &SSHTuner{
		Backup: backup,
	}
}

// Run performs the SSH hardening
func (st *SSHTuner) Run() error {
	PrintStep("SSH Hardening")

	PrintWarning("âš ï¸  WARNING: Incorrect SSH configuration can lock you out!")
	PrintWarning("Ensure you have console access (VMware Remote Console) or a backup session.")
	fmt.Println()
	
	configPath := "/etc/ssh/sshd_config"
	if _, err := os.Stat(configPath); os.IsNotExist(err) {
		return fmt.Errorf("sshd_config not found at %s", configPath)
	}

	// Backup first
	if err := st.Backup.BackupFile(configPath); err != nil {
		return fmt.Errorf("failed to backup sshd_config: %w", err)
	}
	PrintSuccess("Backed up sshd_config")

	// Read config
	contentBytes, err := os.ReadFile(configPath)
	if err != nil {
		return err
	}
	content := string(contentBytes)

	// Ask questions
	changes := false

	// 1. Disable Root Login
	if !strings.Contains(content, "PermitRootLogin no") {
		fmt.Print("Disable SSH Root Login? (y/n): ")
		var resp string
		fmt.Scanln(&resp)
		if resp == "y" {
			// Replace or append
			if strings.Contains(content, "PermitRootLogin") {
				// Simple replace (regex would be better but keeping it simple/safe)
				// We'll just append the override at the end, usually works for sshd
				content += "\n# Added by vmware-tuner\nPermitRootLogin no\n"
			} else {
				content += "\n# Added by vmware-tuner\nPermitRootLogin no\n"
			}
			changes = true
		}
	} else {
		PrintSuccess("Root login already disabled")
	}

	// 2. Disable Password Auth
	if !strings.Contains(content, "PasswordAuthentication no") {
		fmt.Print("Disable Password Authentication (Keys only)? (y/n): ")
		var resp string
		fmt.Scanln(&resp)
		if resp == "y" {
			content += "\n# Added by vmware-tuner\nPasswordAuthentication no\n"
			changes = true
		}
	} else {
		PrintSuccess("Password authentication already disabled")
	}

	if !changes {
		PrintInfo("No changes made")
		return nil
	}

	// Write new config
	if err := os.WriteFile(configPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write sshd_config: %w", err)
	}

	// Verify Config
	PrintInfo("Verifying configuration syntax...")
	cmd := exec.Command("sshd", "-t")
	if output, err := cmd.CombinedOutput(); err != nil {
		PrintError("Configuration check FAILED: %v", err)
		PrintInfo("Output: %s", string(output))
		PrintWarning("Restoring backup immediately...")
		
		// Restore
		backupPath := st.Backup.GetBackupPath("sshd_config")
		exec.Command("cp", backupPath, configPath).Run()
		return fmt.Errorf("safety check failed, changes reverted")
	}

	PrintSuccess("Configuration syntax verified")

	// Restart Service
	fmt.Print("Restart SSH service to apply? (y/n): ")
	var resp string
	fmt.Scanln(&resp)
	if resp == "y" {
		exec.Command("systemctl", "restart", "sshd").Run()
		PrintSuccess("SSH service restarted")
	} else {
		PrintInfo("Changes saved but service not restarted")
	}

	return nil
}


==========================================
FICHIER : internal\tuner\swap.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// SwapTuner handles swap management
type SwapTuner struct{}

// NewSwapTuner creates a new swap tuner
func NewSwapTuner() *SwapTuner {
	return &SwapTuner{}
}

// Run performs the swap check and creation
func (st *SwapTuner) Run() error {
	PrintStep("Swap Manager")

	// 1. Check current swap
	cmd := exec.Command("swapon", "--show")
	out, err := cmd.Output()
	if err == nil && len(out) > 0 {
		PrintSuccess("Swap is currently active:")
		fmt.Println(string(out))
		return nil
	}

	PrintWarning("No active swap detected!")
	PrintInfo("Running without swap can cause the OOM Killer to crash applications.")
	fmt.Println()
	fmt.Print("Create a 2GB swapfile? (y/n): ")
	
	var response string
	fmt.Scanln(&response)
	if response != "y" && response != "yes" {
		PrintInfo("Cancelled")
		return nil
	}

	swapFile := "/swapfile"

	// 2. Create file
	PrintInfo("Creating 2GB swapfile at %s...", swapFile)
	// Try fallocate first (fast)
	if err := exec.Command("fallocate", "-l", "2G", swapFile).Run(); err != nil {
		PrintInfo("fallocate failed, trying dd...")
		// dd if=/dev/zero of=/swapfile bs=1M count=2048
		if err := exec.Command("dd", "if=/dev/zero", "of="+swapFile, "bs=1M", "count=2048").Run(); err != nil {
			return fmt.Errorf("failed to create swapfile: %w", err)
		}
	}

	// 3. Permissions
	os.Chmod(swapFile, 0600)

	// 4. Mkswap
	PrintInfo("Formatting swap...")
	if err := exec.Command("mkswap", swapFile).Run(); err != nil {
		return fmt.Errorf("mkswap failed: %w", err)
	}

	// 5. Swapon
	PrintInfo("Activating swap...")
	if err := exec.Command("swapon", swapFile).Run(); err != nil {
		return fmt.Errorf("swapon failed: %w", err)
	}

	// 6. Persist in fstab
	PrintInfo("Updating /etc/fstab...")
	fstabEntry := fmt.Sprintf("%s none swap sw 0 0\n", swapFile)
	
	// Read fstab to check if already exists
	content, _ := os.ReadFile("/etc/fstab")
	if !strings.Contains(string(content), swapFile) {
		f, err := os.OpenFile("/etc/fstab", os.O_APPEND|os.O_WRONLY, 0644)
		if err != nil {
			PrintWarning("Failed to open fstab: %v", err)
		} else {
			defer f.Close()
			if _, err := f.WriteString(fstabEntry); err != nil {
				PrintWarning("Failed to write to fstab: %v", err)
			} else {
				PrintSuccess("Added to /etc/fstab")
			}
		}
	}

	PrintSuccess("Swap created successfully!")
	return nil
}


==========================================
FICHIER : internal\tuner\sysctl.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// SysctlTuner handles sysctl parameter tuning
type SysctlTuner struct {
	ConfigPath string
	DryRun     bool
}

// NewSysctlTuner creates a new sysctl tuner
func NewSysctlTuner(dryRun bool) *SysctlTuner {
	return &SysctlTuner{
		ConfigPath: "/etc/sysctl.d/99-vmware-performance.conf",
		DryRun:     dryRun,
	}
}

// GetOptimalConfig returns the optimal sysctl configuration for VMware VMs
func (st *SysctlTuner) GetOptimalConfig() string {
	return `# VMware VM Performance Tuning Configuration
# Generated by vmware-tuner
# Date: ` + getCurrentTimestamp() + `

# ============================================
# Memory Management
# ============================================

# Reduce swap usage (recommended for VMs with sufficient RAM)
# Default: 60, Tuned: 10
vm.swappiness = 10

# Percentage of system memory that can be filled with dirty pages before
# processes are forced to write dirty buffers themselves during their time slice
# Default: 20, Tuned: 15
vm.dirty_ratio = 15

# Percentage of system memory that can be filled with dirty pages before
# pdflush/flush/kdmflush starts writing them out
# Default: 10, Tuned: 5
vm.dirty_background_ratio = 5

# Tendency of the kernel to reclaim memory used for caching
# Default: 100, Tuned: 50 (keeps more cache)
vm.vfs_cache_pressure = 50

# ============================================
# Network Performance
# ============================================

# Maximum socket receive buffer
net.core.rmem_max = 134217728

# Maximum socket send buffer
net.core.wmem_max = 134217728

# Default socket receive buffer
net.core.rmem_default = 16777216

# Default socket send buffer
net.core.wmem_default = 16777216

# Maximum number of packets queued on the INPUT side
net.core.netdev_max_backlog = 5000

# TCP receive buffer size (min, default, max)
net.ipv4.tcp_rmem = 4096 87380 67108864

# TCP write buffer size (min, default, max)
net.ipv4.tcp_wmem = 4096 65536 67108864

# TCP congestion control algorithm (BBR for better throughput)
net.ipv4.tcp_congestion_control = bbr

# Enable MTU probing
net.ipv4.tcp_mtu_probing = 1

# Enable TCP window scaling
net.ipv4.tcp_window_scaling = 1

# Enable TCP timestamps
net.ipv4.tcp_timestamps = 1

# Enable selective acknowledgments
net.ipv4.tcp_sack = 1

# Disable TCP slow start after idle
net.ipv4.tcp_slow_start_after_idle = 0

# ============================================
# File System
# ============================================

# Maximum number of file handles
fs.file-max = 2097152

# Maximum number of async I/O requests
fs.aio-max-nr = 1048576

# ============================================
# Kernel
# ============================================

# Increase the maximum number of memory map areas a process may have
vm.max_map_count = 262144
`
}

// Apply applies the sysctl configuration
func (st *SysctlTuner) Apply(backup *BackupManager) error {
	PrintStep("Configuring sysctl parameters")

	// Backup existing config if it exists
	if !st.DryRun {
		if err := backup.BackupFile(st.ConfigPath); err != nil {
			return fmt.Errorf("failed to backup sysctl config: %w", err)
		}
	}

	config := st.GetOptimalConfig()

	if st.DryRun {
		PrintInfo("Would create: %s", st.ConfigPath)
		PrintInfo("Configuration preview:")
		fmt.Println(config)
		return nil
	}

	// Write configuration file
	if err := os.WriteFile(st.ConfigPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write sysctl config: %w", err)
	}

	PrintSuccess("Created %s", st.ConfigPath)

	// Apply sysctl settings immediately
	PrintInfo("Applying sysctl settings...")
	cmd := exec.Command("sysctl", "-p", st.ConfigPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		PrintWarning("Some sysctl parameters may have failed to apply:")
		fmt.Println(string(output))
		PrintWarning("This is normal if BBR congestion control is not available")
	} else {
		PrintSuccess("Sysctl parameters applied successfully")
	}

	return nil
}

// ShowCurrent displays current sysctl values
func (st *SysctlTuner) ShowCurrent() error {
	PrintStep("Current sysctl values")

	params := []string{
		"vm.swappiness",
		"vm.dirty_ratio",
		"vm.dirty_background_ratio",
		"vm.vfs_cache_pressure",
		"net.core.rmem_max",
		"net.core.wmem_max",
		"net.ipv4.tcp_congestion_control",
		"fs.file-max",
	}

	for _, param := range params {
		cmd := exec.Command("sysctl", "-n", param)
		output, err := cmd.Output()
		if err != nil {
			PrintWarning("Could not read %s", param)
			continue
		}

		value := strings.TrimSpace(string(output))
		fmt.Printf("  %s = %s\n", param, value)
	}

	return nil
}

// Verify checks if the sysctl configuration has been applied
func (st *SysctlTuner) Verify() error {
	if _, err := os.Stat(st.ConfigPath); os.IsNotExist(err) {
		return fmt.Errorf("configuration file not found: %s", st.ConfigPath)
	}

	PrintSuccess("Sysctl configuration file exists")
	return nil
}


==========================================
FICHIER : internal\tuner\template.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
)

// TemplateTuner handles VM sealing
type TemplateTuner struct{}

// NewTemplateTuner creates a new template tuner
func NewTemplateTuner() *TemplateTuner {
	return &TemplateTuner{}
}

// Run performs the sealing process
func (tt *TemplateTuner) Run() error {
	PrintStep("Seal VM for Template")

	PrintWarning("âš ï¸  DANGER ZONE âš ï¸")
	PrintWarning("This will remove unique system identifiers (Machine ID, SSH Keys, Logs).")
	PrintWarning("The VM will be shut down immediately after.")
	PrintWarning("DO NOT RUN THIS if you are not creating a template/golden image.")
	fmt.Println()
	
	fmt.Print("Type 'SEAL' to continue: ")
	var response string
	fmt.Scanln(&response)
	
	if response != "SEAL" {
		PrintInfo("Operation cancelled (Safety check failed)")
		return nil
	}

	PrintInfo("Preparing system for templating...")

	// 1. Clean Machine ID
	// /etc/machine-id should be empty, not missing, for systemd to regenerate it
	PrintInfo("Resetting Machine ID...")
	if err := os.Truncate("/etc/machine-id", 0); err != nil {
		PrintWarning("Failed to truncate /etc/machine-id: %v", err)
	}
	os.Remove("/var/lib/dbus/machine-id")

	// 2. Remove SSH Host Keys
	PrintInfo("Removing SSH Host Keys...")
	exec.Command("rm", "-f", "/etc/ssh/ssh_host_*").Run()

	// 3. Clean Logs
	PrintInfo("Vacuuming logs...")
	exec.Command("journalctl", "--vacuum-time=1s").Run()
	exec.Command("rm", "-f", "/var/log/*.gz").Run()
	exec.Command("rm", "-f", "/var/log/*.[0-9]").Run()

	// 4. Clean Bash History
	PrintInfo("Clearing shell history...")
	os.Remove("/root/.bash_history")
	exec.Command("history", "-c").Run()

	// 5. Clean Package Cache (Reuse logic if possible, but simple command here is fine)
	PrintInfo("Cleaning package cache...")
	exec.Command("apt-get", "clean").Run()
	exec.Command("yum", "clean", "all").Run()

	PrintSuccess("System sealed successfully!")
	PrintInfo("Shutting down in 3 seconds...")
	
	exec.Command("sleep", "3").Run()
	exec.Command("poweroff").Run()

	return nil
}


==========================================
FICHIER : internal\tuner\timesync.go
==========================================
package tuner

import (
	"fmt"
	"os/exec"
)

// TimeSyncTuner handles time synchronization
type TimeSyncTuner struct {
	Distro *DistroManager
}

// NewTimeSyncTuner creates a new time sync tuner
func NewTimeSyncTuner(distro *DistroManager) *TimeSyncTuner {
	return &TimeSyncTuner{
		Distro: distro,
	}
}

// Run performs the time sync check and fix
func (t *TimeSyncTuner) Run() error {
	PrintStep("Time Synchronization Doctor")

	// 1. Check for existing NTP services
	services := []string{"chronyd", "ntp", "systemd-timesyncd"}
	activeService := ""

	for _, svc := range services {
		cmd := exec.Command("systemctl", "is-active", svc)
		if err := cmd.Run(); err == nil {
			activeService = svc
			break
		}
	}

	if activeService != "" {
		PrintSuccess("Time synchronization is active via: %s", activeService)
		
		// Force sync
		PrintInfo("Forcing time synchronization...")
		if activeService == "chronyd" {
			exec.Command("chronyc", "makestep").Run()
		} else if activeService == "systemd-timesyncd" {
			// systemd-timesyncd doesn't have a simple force command, restart triggers it
			exec.Command("systemctl", "restart", "systemd-timesyncd").Run()
		}
		
		// Ensure VMware Tools sync is disabled to avoid conflict
		PrintInfo("Disabling VMware Tools periodic time sync (best practice with NTP)...")
		exec.Command("vmware-toolbox-cmd", "timesync", "disable").Run()
		
		return nil
	}

	PrintWarning("No active NTP service found!")
	
	// 2. If no NTP, offer to enable VMware Tools sync or install chrony
	fmt.Println()
	fmt.Println("Options:")
	fmt.Println("  [1] Install/Enable Chrony (Recommended)")
	fmt.Println("  [2] Enable VMware Tools Host Sync (Fallback)")
	fmt.Println("  [3] Skip")
	fmt.Print("Choice: ")
	
	var choice string
	fmt.Scanln(&choice)

	if choice == "1" {
		pkg := "chrony"
		if t.Distro.Type == DistroDebian {
			pkg = "chrony"
		}
		if err := t.Distro.InstallPackage(pkg); err != nil {
			return err
		}
		exec.Command("systemctl", "enable", "--now", "chronyd").Run()
		exec.Command("chronyc", "makestep").Run()
		PrintSuccess("Chrony installed and synchronized")
	} else if choice == "2" {
		if err := exec.Command("vmware-toolbox-cmd", "timesync", "enable").Run(); err != nil {
			return fmt.Errorf("failed to enable vmtools sync: %v", err)
		}
		PrintSuccess("VMware Tools Host Sync enabled")
	} else {
		PrintInfo("Skipping time sync")
	}

	return nil
}


==========================================
FICHIER : internal\tuner\update.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// UpdateTuner handles system updates
type UpdateTuner struct {
	Distro *DistroManager
}

// NewUpdateTuner creates a new update tuner
func NewUpdateTuner(distro *DistroManager) *UpdateTuner {
	return &UpdateTuner{
		Distro: distro,
	}
}

// Run performs the update
func (ut *UpdateTuner) Run() error {
	PrintStep("Safe System Update")

	// 1. Check Disk Space
	PrintInfo("Checking disk space...")
	cmd := exec.Command("df", "--output=avail", "/")
	out, err := cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to check disk space: %w", err)
	}
	
	// Simple check: ensure we have enough bytes (rough approximation from output)
	// Real implementation would parse strictly. Here we rely on the user seeing the output if we just show it?
	// No, let's try to be safer.
	// Output is like:
	// Avail
	// 10240000
	lines := strings.Split(strings.TrimSpace(string(out)), "\n")
	if len(lines) >= 2 {
		availStr := strings.TrimSpace(lines[1])
		var avail int64
		fmt.Sscanf(availStr, "%d", &avail)
		
		// df outputs 1K blocks usually
		availMB := avail / 1024
		if availMB < 1000 {
			PrintError("Insufficient disk space! Only %d MB free.", availMB)
			PrintInfo("At least 1000 MB is recommended for safe updates.")
			return fmt.Errorf("disk space check failed")
		}
		PrintSuccess("Disk space OK (%d MB free)", availMB)
	}

	// 2. Run Update
	fmt.Println()
	PrintInfo("Ready to update system packages.")
	fmt.Print("Continue? (y/n): ")
	var resp string
	fmt.Scanln(&resp)
	if resp != "y" {
		PrintInfo("Cancelled")
		return nil
	}

	var updateCmd *exec.Cmd
	if ut.Distro.Type == DistroDebian {
		// Interactive update
		cmdStr := "apt-get update && apt-get upgrade"
		updateCmd = exec.Command("bash", "-c", cmdStr)
	} else if ut.Distro.Type == DistroRHEL {
		if _, err := exec.LookPath("dnf"); err == nil {
			updateCmd = exec.Command("dnf", "update")
		} else {
			updateCmd = exec.Command("yum", "update")
		}
	} else {
		return fmt.Errorf("unsupported distribution for auto-update")
	}

	updateCmd.Stdout = os.Stdout
	updateCmd.Stderr = os.Stderr
	updateCmd.Stdin = os.Stdin

	if err := updateCmd.Run(); err != nil {
		return fmt.Errorf("update failed: %w", err)
	}

	PrintSuccess("System updated successfully!")

	// 3. Check Reboot
	rebootNeeded := false
	if ut.Distro.Type == DistroDebian {
		if _, err := os.Stat("/var/run/reboot-required"); err == nil {
			rebootNeeded = true
		}
	} else if ut.Distro.Type == DistroRHEL {
		// needs-restarting -r (yum-utils)
		if err := exec.Command("needs-restarting", "-r").Run(); err != nil {
			// Exit code 1 means reboot needed
			rebootNeeded = true
		}
	}

	if rebootNeeded {
		PrintWarning("A reboot is required to apply updates.")
		fmt.Print("Reboot now? (y/n): ")
		fmt.Scanln(&resp)
		if resp == "y" {
			exec.Command("reboot").Run()
		}
	} else {
		PrintSuccess("No reboot required.")
	}

	return nil
}


==========================================
FICHIER : internal\tuner\utils.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"time"

	"github.com/fatih/color"
)

var (
	// Color definitions
	colorSuccess = color.New(color.FgGreen, color.Bold)
	colorError   = color.New(color.FgRed, color.Bold)
	colorWarning = color.New(color.FgYellow, color.Bold)
	colorInfo    = color.New(color.FgCyan)
	colorStep    = color.New(color.FgMagenta, color.Bold)
)

// PrintSuccess prints a success message
func PrintSuccess(format string, args ...interface{}) {
	colorSuccess.Print("âœ“ ")
	fmt.Printf(format+"\n", args...)
}

// PrintError prints an error message
func PrintError(format string, args ...interface{}) {
	colorError.Print("âœ— ")
	fmt.Fprintf(os.Stderr, format+"\n", args...)
}

// PrintWarning prints a warning message
func PrintWarning(format string, args ...interface{}) {
	colorWarning.Print("âš  ")
	fmt.Printf(format+"\n", args...)
}

// PrintInfo prints an info message
func PrintInfo(format string, args ...interface{}) {
	colorInfo.Print("â„¹ ")
	fmt.Printf(format+"\n", args...)
}

// PrintStep prints a step header
func PrintStep(format string, args ...interface{}) {
	fmt.Println()
	colorStep.Printf("â–¶ "+format+"\n", args...)
	fmt.Println(separator())
}

// separator returns a visual separator
func separator() string {
	return "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
}

// getCurrentTimestamp returns the current timestamp as a string
func getCurrentTimestamp() string {
	return time.Now().Format("2006-01-02 15:04:05")
}

// CheckRoot checks if the program is running as root
func CheckRoot() error {
	if os.Geteuid() != 0 {
		return fmt.Errorf("this program must be run as root (use sudo)")
	}
	return nil
}

// FileExists checks if a file exists
func FileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// IsVMware checks if running on VMware
func IsVMware() (bool, error) {
	// Check DMI product name
	data, err := os.ReadFile("/sys/class/dmi/id/product_name")
	if err == nil {
		productName := string(data)
		if contains(productName, "VMware") {
			return true, nil
		}
	}

	// Check for VMware in /proc/cpuinfo
	data, err = os.ReadFile("/proc/cpuinfo")
	if err == nil {
		cpuInfo := string(data)
		if contains(cpuInfo, "VMware") || contains(cpuInfo, "hypervisor") {
			return true, nil
		}
	}

	// Check for vmware modules
	data, err = os.ReadFile("/proc/modules")
	if err == nil {
		modules := string(data)
		if contains(modules, "vmw_") || contains(modules, "vmxnet") {
			return true, nil
		}
	}

	return false, nil
}

// contains checks if a string contains a substring (case-insensitive)
func contains(s, substr string) bool {
	return len(s) >= len(substr) && (s == substr || len(substr) == 0 ||
		(len(s) > 0 && len(substr) > 0 && containsHelper(s, substr)))
}

func containsHelper(s, substr string) bool {
	for i := 0; i <= len(s)-len(substr); i++ {
		if s[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}

// Banner prints the application banner
func Banner() {
	banner := `
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                          â•‘
â•‘           VMware VM Performance Tuner                    â•‘
â•‘                                                          â•‘
â•‘  Optimize your VMware virtual machine for maximum        â•‘
â•‘  performance with industry-standard best practices       â•‘
â•‘                                                          â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
`
	colorStep.Println(banner)
}

// Summary prints a summary of what will be done
func Summary(modules []string) {
	PrintStep("Tuning Summary")
	fmt.Println("The following optimizations will be applied:")
	fmt.Println()

	for i, module := range modules {
		fmt.Printf("  %d. %s\n", i+1, module)
	}

	fmt.Println()
}

// CompletionMessage prints the completion message
func CompletionMessage(rebootRequired bool) {
	fmt.Println()
	colorSuccess.Println("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
	colorSuccess.Println("â•‘                                                          â•‘")
	colorSuccess.Println("â•‘            Tuning Completed Successfully!                â•‘")
	colorSuccess.Println("â•‘                                                          â•‘")
	colorSuccess.Println("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
	fmt.Println()

	if rebootRequired {
		PrintWarning("IMPORTANT: A system reboot is required for all changes to take effect")
		PrintInfo("Run: sudo reboot")
		fmt.Println()
	}

	PrintInfo("Backup location: /root/.vmware-tuner-backups/")
	PrintInfo("To rollback changes, see the rollback.sh script in the backup directory")
	fmt.Println()
}


==========================================
FICHIER : internal\tuner\vmtools.go
==========================================
package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"
)

// VMToolsTuner handles open-vm-tools installation and configuration
type VMToolsTuner struct {
	Distro *DistroManager
	DryRun bool
}

// NewVMToolsTuner creates a new VM tools tuner
func NewVMToolsTuner(dryRun bool, distro *DistroManager) *VMToolsTuner {
	return &VMToolsTuner{
		Distro: distro,
		DryRun: dryRun,
	}
}

// CheckInstalled checks if open-vm-tools is installed
func (vt *VMToolsTuner) CheckInstalled() bool {
	_, err := exec.LookPath("vmtoolsd")
	return err == nil
}

// Apply installs and enables open-vm-tools
func (vt *VMToolsTuner) Apply() error {
	PrintStep("Checking VMware Tools")

	if vt.CheckInstalled() {
		PrintSuccess("open-vm-tools is already installed")
		return vt.ensureService()
	}

	PrintInfo("open-vm-tools is missing")
	
	if vt.DryRun {
		PrintInfo("Would install open-vm-tools package")
		return nil
	}

	// Install package
	if err := vt.Distro.InstallPackage("open-vm-tools"); err != nil {
		return fmt.Errorf("failed to install open-vm-tools: %w", err)
	}

	return vt.ensureService()
}

// ensureService makes sure the service is running
func (vt *VMToolsTuner) ensureService() error {
	if vt.DryRun {
		return nil
	}

	// Service name is usually open-vm-tools or vmtoolsd
	serviceName := "open-vm-tools"
	if vt.Distro.Type == DistroRHEL {
		// On RHEL/CentOS it might be vmtoolsd
		serviceName = "vmtoolsd"
	}

	PrintInfo("Ensuring %s service is running...", serviceName)
	
	// Enable
	exec.Command("systemctl", "enable", serviceName).Run()
	
	// Start
	cmd := exec.Command("systemctl", "start", serviceName)
	if err := cmd.Run(); err != nil {
		// Try alternative name if failed
		if serviceName == "open-vm-tools" {
			serviceName = "vmtoolsd"
		} else {
			serviceName = "open-vm-tools"
		}
		exec.Command("systemctl", "enable", serviceName).Run()
		exec.Command("systemctl", "start", serviceName).Run()
	}

	PrintSuccess("VMware Tools service configured")
	return nil
}

// CheckUpdateStatus returns installed, updateAvailable, daysSinceLastUpdate, error
func (vt *VMToolsTuner) CheckUpdateStatus() (bool, bool, int, error) {
	if !vt.CheckInstalled() {
		return false, false, 0, nil
	}

	// Check binary age
	binPath, err := exec.LookPath("vmtoolsd")
	days := 0
	if err == nil {
		info, err := os.Stat(binPath)
		if err == nil {
			days = int(time.Since(info.ModTime()).Hours() / 24)
		}
	}

	// Check for updates
	updateAvailable := vt.IsUpdateAvailable()

	return true, updateAvailable, days, nil
}

// IsUpdateAvailable checks if an update is available via package manager
func (vt *VMToolsTuner) IsUpdateAvailable() bool {
	// This is a "best effort" check based on local cache
	if vt.Distro.Type == DistroDebian {
		// apt-get -s install --only-upgrade open-vm-tools
		cmd := exec.Command("apt-get", "-s", "install", "--only-upgrade", "open-vm-tools")
		out, err := cmd.CombinedOutput()
		if err == nil && strings.Contains(string(out), "Inst open-vm-tools") {
			return true
		}
	} else if vt.Distro.Type == DistroRHEL {
		// yum check-update open-vm-tools
		// Exit code 100 means updates available
		cmd := exec.Command("yum", "check-update", "open-vm-tools")
		err := cmd.Run()
		if err != nil {
			if exitError, ok := err.(*exec.ExitError); ok {
				if exitError.ExitCode() == 100 {
					return true
				}
			}
		}
	}
	return false
}

// UpdateTools attempts to update the package
func (vt *VMToolsTuner) UpdateTools() error {
	PrintInfo("Updating open-vm-tools...")
	if err := vt.Distro.InstallPackage("open-vm-tools"); err != nil {
		return err
	}
	return vt.ensureService()
}


==========================================
FICHIER : go.mod
==========================================
module vmware-tuner

go 1.19

require (
	github.com/fatih/color v1.16.0
	github.com/spf13/cobra v1.8.0
)

require (
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/mattn/go-colorable v0.1.13 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	golang.org/x/sys v0.14.0 // indirect
)


