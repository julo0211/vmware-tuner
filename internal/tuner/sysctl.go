package tuner

import (
	"fmt"
	"os"
	"os/exec"
	"strings"
)

// SysctlTuner handles sysctl parameter tuning
type SysctlTuner struct {
	ConfigPath string
	DryRun     bool
}

// NewSysctlTuner creates a new sysctl tuner
func NewSysctlTuner(dryRun bool) *SysctlTuner {
	return &SysctlTuner{
		ConfigPath: "/etc/sysctl.d/99-vmware-performance.conf",
		DryRun:     dryRun,
	}
}

// GetOptimalConfig returns the optimal sysctl configuration for VMware VMs
func (st *SysctlTuner) GetOptimalConfig() string {
	return `# VMware VM Performance Tuning Configuration
# Generated by vmware-tuner
# Date: ` + getCurrentTimestamp() + `

# ============================================
# Memory Management
# ============================================

# Reduce swap usage (recommended for VMs with sufficient RAM)
# Default: 60, Tuned: 10
vm.swappiness = 10

# Percentage of system memory that can be filled with dirty pages before
# processes are forced to write dirty buffers themselves during their time slice
# Default: 20, Tuned: 15
vm.dirty_ratio = 15

# Percentage of system memory that can be filled with dirty pages before
# pdflush/flush/kdmflush starts writing them out
# Default: 10, Tuned: 5
vm.dirty_background_ratio = 5

# Tendency of the kernel to reclaim memory used for caching
# Default: 100, Tuned: 50 (keeps more cache)
vm.vfs_cache_pressure = 50

# ============================================
# Network Performance
# ============================================

# Maximum socket receive buffer
net.core.rmem_max = 134217728

# Maximum socket send buffer
net.core.wmem_max = 134217728

# Default socket receive buffer
net.core.rmem_default = 16777216

# Default socket send buffer
net.core.wmem_default = 16777216

# Maximum number of packets queued on the INPUT side
net.core.netdev_max_backlog = 5000

# TCP receive buffer size (min, default, max)
net.ipv4.tcp_rmem = 4096 87380 67108864

# TCP write buffer size (min, default, max)
net.ipv4.tcp_wmem = 4096 65536 67108864

# TCP congestion control algorithm (BBR for better throughput)
net.ipv4.tcp_congestion_control = bbr

# Enable MTU probing
net.ipv4.tcp_mtu_probing = 1

# Enable TCP window scaling
net.ipv4.tcp_window_scaling = 1

# Enable TCP timestamps
net.ipv4.tcp_timestamps = 1

# Enable selective acknowledgments
net.ipv4.tcp_sack = 1

# Disable TCP slow start after idle
net.ipv4.tcp_slow_start_after_idle = 0

# ============================================
# File System
# ============================================

# Maximum number of file handles
fs.file-max = 2097152

# Maximum number of async I/O requests
fs.aio-max-nr = 1048576

# ============================================
# Kernel
# ============================================

# Increase the maximum number of memory map areas a process may have
vm.max_map_count = 262144
`
}

// Apply applies the sysctl configuration
func (st *SysctlTuner) Apply(backup *BackupManager) error {
	PrintStep("Configuring sysctl parameters")

	// Backup existing config if it exists
	if !st.DryRun {
		if err := backup.BackupFile(st.ConfigPath); err != nil {
			return fmt.Errorf("failed to backup sysctl config: %w", err)
		}
	}

	config := st.GetOptimalConfig()

	if st.DryRun {
		PrintInfo("Would create: %s", st.ConfigPath)
		PrintInfo("Configuration preview:")
		fmt.Println(config)
		return nil
	}

	// Write configuration file
	if err := os.WriteFile(st.ConfigPath, []byte(config), 0644); err != nil {
		return fmt.Errorf("failed to write sysctl config: %w", err)
	}

	PrintSuccess("Created %s", st.ConfigPath)

	// Apply sysctl settings immediately
	PrintInfo("Applying sysctl settings...")
	cmd := exec.Command("sysctl", "-p", st.ConfigPath)
	output, err := cmd.CombinedOutput()
	if err != nil {
		PrintWarning("Some sysctl parameters may have failed to apply:")
		fmt.Println(string(output))
		PrintWarning("This is normal if BBR congestion control is not available")
	} else {
		PrintSuccess("Sysctl parameters applied successfully")
	}

	return nil
}

// ShowCurrent displays current sysctl values
func (st *SysctlTuner) ShowCurrent() error {
	PrintStep("Current sysctl values")

	params := []string{
		"vm.swappiness",
		"vm.dirty_ratio",
		"vm.dirty_background_ratio",
		"vm.vfs_cache_pressure",
		"net.core.rmem_max",
		"net.core.wmem_max",
		"net.ipv4.tcp_congestion_control",
		"fs.file-max",
	}

	for _, param := range params {
		cmd := exec.Command("sysctl", "-n", param)
		output, err := cmd.Output()
		if err != nil {
			PrintWarning("Could not read %s", param)
			continue
		}

		value := strings.TrimSpace(string(output))
		fmt.Printf("  %s = %s\n", param, value)
	}

	return nil
}

// Verify checks if the sysctl configuration has been applied
func (st *SysctlTuner) Verify() error {
	if _, err := os.Stat(st.ConfigPath); os.IsNotExist(err) {
		return fmt.Errorf("configuration file not found: %s", st.ConfigPath)
	}

	PrintSuccess("Sysctl configuration file exists")
	return nil
}
